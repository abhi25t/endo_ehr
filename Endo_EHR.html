<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AIG Endoscopy Report</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <link href="https://cdn.quilljs.com/1.3.7/quill.snow.css" rel="stylesheet">
  <script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <style>
    body { font-family: Inter, system-ui, sans-serif; }
    .loc-column { min-height: 320px; max-height: 420px; overflow:auto; }
    .pill, .attr-pill {
      cursor:pointer; border:1px solid #93c5fd; background:#fff;
      color:#1e40af; padding:.35rem .6rem; border-radius:.5rem;
      font-size:.875rem; transition:all .15s;
    }
    .pill:hover, .attr-pill:hover { background:#eff6ff; }
    .pill-selected, .attr-pill.selected {
      background:#2563eb; color:#fff; border-color:#1d4ed8;
    }
    .left-disease {
      display:block; text-align:left; width:100%;
      padding:.5rem .75rem; border-radius:.5rem;
      border:1px solid transparent; background:#fff; color:#1f2937;
    }
    .left-disease:hover { background:#f1f5f9; }
    .left-disease.selected {
      background:#2563eb; color:#fff; border-color:#1e40af;
    }
    #sentencesEditor h1 { font-size: 2em; font-weight: bold; }
    #sentencesEditor h2 { font-size: 1.5em; font-weight: bold; margin-top: 0.5em; }
    #sentencesEditor h3 { font-size: 1.17em; font-weight: bold; margin-top: 0.3em; }
    #sentencesEditor p { margin-bottom: 0.5em; }

    /* Portrait mode: greyed-out elements */
    .left-disease.portrait-greyed, .pill.portrait-greyed {
      opacity: 0.35; cursor: not-allowed;
    }
    /* Portrait mode: focused disease (selected but not yet added to report) */
    .left-disease.portrait-focused {
      border-color: #3b82f6; background: #eff6ff;
    }

    /* Settings toggle switch */
    .toggle-switch { width: 2.75rem; height: 1.5rem; border-radius: 9999px; position: relative; cursor: pointer; transition: background-color 0.2s; }
    .toggle-knob { position: absolute; top: 2px; left: 2px; width: 1.15rem; height: 1.15rem; border-radius: 9999px; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.2); transition: transform 0.2s; }
    .toggle-switch.active .toggle-knob { transform: translateX(1.25rem); }

    /* ── Dark mode overrides ── */
    body.dark { background-color: #111827 !important; color: #f3f4f6 !important; }
    body.dark .bg-white { background-color: #1f2937 !important; }
    body.dark .bg-gray-100 { background-color: #111827 !important; }
    body.dark .bg-gray-50 { background-color: #374151 !important; }
    body.dark .bg-blue-50 { background-color: #1e3a5f !important; }
    body.dark .text-gray-800 { color: #f3f4f6 !important; }
    body.dark .text-gray-700 { color: #d1d5db !important; }
    body.dark .text-gray-600 { color: #d1d5db !important; }
    body.dark .text-gray-500 { color: #9ca3af !important; }
    body.dark .text-gray-400 { color: #9ca3af !important; }
    body.dark .text-blue-700 { color: #60a5fa !important; }
    body.dark .text-blue-600 { color: #60a5fa !important; }
    body.dark .text-yellow-700 { color: #fbbf24 !important; }
    body.dark .border { border-color: #4b5563 !important; }
    body.dark .border-gray-200 { border-color: #4b5563 !important; }
    body.dark .border-blue-200 { border-color: #2563eb !important; }
    body.dark .shadow { box-shadow: 0 1px 3px 0 rgba(0,0,0,0.4) !important; }
    body.dark input, body.dark textarea, body.dark select {
      background-color: #374151 !important; color: #f3f4f6 !important; border-color: #6b7280 !important;
    }
    body.dark .pill, body.dark .attr-pill {
      background: #374151; color: #93c5fd; border-color: #3b82f6;
    }
    body.dark .pill:hover, body.dark .attr-pill:hover { background: #4b5563; }
    body.dark .pill-selected, body.dark .attr-pill.selected {
      background: #2563eb; color: #fff; border-color: #3b82f6;
    }
    body.dark .left-disease {
      background: #374151; color: #f3f4f6;
    }
    body.dark .left-disease:hover { background: #4b5563; }
    body.dark .left-disease.portrait-focused { border-color: #3b82f6; background: #1e3a5f; }
    body.dark .left-disease.selected {
      background: #2563eb; color: #fff; border-color: #3b82f6;
    }
    body.dark .hover\:bg-gray-200:hover { background-color: #4b5563 !important; }
    body.dark .ql-toolbar { background-color: #1f2937 !important; border-color: #4b5563 !important; }
    body.dark .ql-toolbar .ql-stroke { stroke: #d1d5db !important; }
    body.dark .ql-toolbar .ql-fill { fill: #d1d5db !important; }
    body.dark .ql-toolbar .ql-picker-label { color: #d1d5db !important; }
    body.dark .ql-container { background-color: #1f2937 !important; border-color: #4b5563 !important; color: #f3f4f6 !important; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800">
<div class="max-w-full mx-auto p-6 relative">
  <h1 id="pageTitle" class="text-2xl font-bold text-center text-blue-700 mb-6">AIG Endoscopy Report</h1>

  <!-- Settings Gear Button -->
  <div class="absolute top-6 right-6 z-50">
    <button id="settingsGearBtn" class="p-2 rounded-full hover:bg-gray-200 text-gray-600 text-xl" title="Settings">
      &#9881;
    </button>
    <div id="settingsPanel" class="hidden absolute right-0 mt-2 w-72 bg-white rounded-lg shadow-lg border p-4 z-50">
      <!-- Procedure Type -->
      <div class="mb-4 pb-3 border-b">
        <div class="text-sm font-medium text-gray-700 mb-2">Procedure Type</div>
        <div class="flex gap-4">
          <label class="flex items-center gap-1.5 text-sm cursor-pointer">
            <input type="radio" name="procedureType" value="endoscopy" checked class="accent-blue-600" /> Endoscopy
          </label>
          <label class="flex items-center gap-1.5 text-sm cursor-pointer">
            <input type="radio" name="procedureType" value="colonoscopy" class="accent-blue-600" /> Colonoscopy
          </label>
        </div>
      </div>
      <!-- Dark Mode Toggle -->
      <div class="flex items-center justify-between mb-4 pb-3 border-b">
        <label class="text-sm font-medium text-gray-700 flex items-center gap-2">
          <span class="text-lg">&#9790;</span> Dark Mode
        </label>
        <div id="darkModeToggle" class="toggle-switch bg-gray-300">
          <div class="toggle-knob"></div>
        </div>
      </div>
      <!-- Study Type -->
      <div class="mb-4 pb-3 border-b">
        <div class="text-sm font-medium text-gray-700 mb-2">Study Type</div>
        <div class="flex gap-4">
          <label class="flex items-center gap-1.5 text-sm cursor-pointer">
            <input type="radio" name="studyType" value="retrospective" checked class="accent-blue-600" /> Retrospective
          </label>
          <label class="flex items-center gap-1.5 text-sm cursor-pointer">
            <input type="radio" name="studyType" value="prospective" class="accent-blue-600" /> Prospective
          </label>
        </div>
      </div>
      <!-- Display Mode -->
      <div class="mb-4 pb-3 border-b">
        <div class="text-sm font-medium text-gray-700 mb-2">Display Mode</div>
        <div class="flex gap-4">
          <label id="landscapeLabel" class="flex items-center gap-1.5 text-sm cursor-pointer">
            <input type="radio" name="displayMode" value="landscape" checked class="accent-blue-600" /> Landscape
          </label>
          <label class="flex items-center gap-1.5 text-sm cursor-pointer">
            <input type="radio" name="displayMode" value="portrait" class="accent-blue-600" /> Portrait
          </label>
        </div>
      </div>
      <!-- CSV File -->
      <div>
        <div class="text-sm font-medium text-gray-700 mb-2">CSV Menu File</div>
        <div class="text-xs text-gray-500 mb-1" id="csvAutoStatus"></div>
        <input id="csvFile" type="file" accept=".csv" class="text-sm w-full" />
        <button id="loadSample" class="mt-1 px-3 py-1 rounded border text-sm bg-white hover:bg-gray-50 w-full">Load sample</button>
      </div>
    </div>
  </div>

  <!-- Retrospective Controls -->
  <div id="retroControls" class="mb-3 bg-white p-4 rounded shadow">
    <div class="flex items-center gap-6 flex-wrap">
      <!-- Load Videos Folder Button -->
      <button id="loadVideoFolder" class="bg-purple-600 text-white px-3 py-2 rounded text-sm hover:bg-purple-700">
        Load Videos Folder
      </button>

      <!-- UHID Dropdown -->
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">UHID:</label>
        <select id="uhidSelect" class="border rounded p-2 text-sm min-w-[150px]">
          <option value="">-- Select UHID --</option>
        </select>
      </div>

      <!-- Video Dropdown -->
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">Video:</label>
        <select id="videoSelect" class="border rounded p-2 text-sm min-w-[200px]" disabled>
          <option value="">-- Select Video --</option>
        </select>
      </div>

      <!-- Frame Range Inputs -->
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">Start Frame:</label>
        <input type="number" id="startFrame" class="border rounded p-2 text-sm w-24" min="0" step="1" placeholder="0" />
      </div>

      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">End Frame:</label>
        <input type="number" id="endFrame" class="border rounded p-2 text-sm w-24" min="0" step="1" placeholder="0" />
      </div>

      <!-- Frame Count and Duration Display -->
      <div class="flex items-center gap-4 text-sm">
        <span class="text-gray-700"># Frames: <strong id="frameCount">0</strong></span>
        <span class="text-gray-700">Duration: <strong id="durationSec">0.00</strong> sec</span>
      </div>

      <!-- Segmentation Frame Input -->
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">Segmentation Frame:</label>
        <input type="number" id="segmentationFrame" class="border rounded p-2 text-sm w-24" min="0" step="1" placeholder="0" />
      </div>

      <!-- PII Pill Toggle -->
      <button id="piiToggle" class="px-3 py-2 rounded text-sm border-2 border-orange-400 bg-white text-orange-600 hover:bg-orange-50">
        PII
      </button>
    </div>
  </div>

  <!-- Prospective Controls (hidden by default) -->
  <div id="prospControls" class="mb-3 bg-white p-4 rounded shadow hidden">
    <div class="flex items-center gap-6 flex-wrap">
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">UHID:</label>
        <input type="text" id="prospUhid" class="border rounded p-2 text-sm w-32" placeholder="UHID" />
      </div>
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">Patient Name:</label>
        <input type="text" id="prospPatientName" class="border rounded p-2 text-sm w-48" placeholder="Name" />
      </div>
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">Gender:</label>
        <input type="text" id="prospGender" class="border rounded p-2 text-sm w-24" placeholder="M/F" />
      </div>
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">Age:</label>
        <input type="text" id="prospAge" class="border rounded p-2 text-sm w-20" placeholder="Age" />
      </div>
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-700">Indication:</label>
        <input type="text" id="prospIndication" class="border rounded p-2 text-sm w-64" placeholder="Indication for procedure" />
      </div>
    </div>
  </div>

  <!-- Shared Controls (Voice) - always visible -->
  <div id="sharedControls" class="mb-3 bg-white p-4 rounded shadow">
    <div class="flex items-center gap-6 flex-wrap">
      <!-- Voice Dictation Toggle -->
      <button id="voiceToggle" disabled
        class="bg-green-600 text-white px-4 py-2 rounded text-sm hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
        title="Load CSV first">
        Start Dictation
      </button>
      <span id="voiceStatus" class="text-sm text-gray-500"></span>
    </div>
    <div id="csvNote" class="text-sm text-yellow-700 mt-2"></div>
    <!-- Voice Transcript Bar -->
    <div id="voiceTranscriptBar" class="hidden mt-2 px-3 py-2 bg-gray-50 rounded border border-gray-200 flex items-center gap-2">
      <span class="text-xs font-medium text-gray-500 shrink-0">Transcript:</span>
      <span id="voiceTranscriptText" class="text-sm truncate text-gray-400 italic"></span>
    </div>
  </div>

  <div id="mainLayout" class="flex gap-6">
    <!-- LEFT -->
    <div id="leftPane" class="w-3/4 space-y-4">
      <div id="diseaseGridCard" class="bg-white p-4 rounded shadow">
        <div id="diseaseColumnsGrid" class="grid grid-cols-4 gap-4">
          <div>
            <h3 class="text-blue-600 font-semibold mb-2">Esophagus</h3>
            <div id="col-esophagus" class="loc-column space-y-2"></div>
          </div>
          <div>
            <h3 class="text-blue-600 font-semibold mb-2">GE Junction</h3>
            <div id="col-gejunction" class="loc-column space-y-2"></div>
          </div>
          <div>
            <h3 class="text-blue-600 font-semibold mb-2">Stomach</h3>
            <div id="col-stomach" class="loc-column space-y-2"></div>
          </div>
          <div>
            <h3 class="text-blue-600 font-semibold mb-2">Duodenum</h3>
            <div id="col-duodenum" class="loc-column space-y-2"></div>
          </div>
        </div>
        <div id="sublocSection" class="mt-4 bg-blue-50 p-4 rounded">
          <div class="font-medium mb-2 text-sm text-gray-700">
            Sub-Location <span class="text-xs italic text-gray-500">(multi-select)</span>
          </div>
          <div id="subloc-chips" class="flex gap-2 flex-wrap"></div>
        </div>
      </div>

      <div id="detailsCard" class="bg-white p-4 rounded shadow hidden">
        <div class="mb-3">
          <div class="text-lg font-semibold" id="detailsTitle">Details</div>
          <div class="text-sm text-gray-500" id="detailsSubTitle"></div>
        </div>

        <!-- Disease-specific Frame Controls -->
        <div id="diseaseFrameBar" class="mb-4 p-3 bg-blue-50 rounded border border-blue-200">
          <div class="flex items-center gap-4 flex-wrap">
            <div class="flex items-center gap-2">
              <label class="text-sm font-medium text-gray-700">Start Frame:</label>
              <input type="number" id="diseaseStartFrame" class="border rounded p-1 text-sm w-20" min="0" step="1" placeholder="0" />
            </div>
            <div class="flex items-center gap-2">
              <label class="text-sm font-medium text-gray-700">End Frame:</label>
              <input type="number" id="diseaseEndFrame" class="border rounded p-1 text-sm w-20" min="0" step="1" placeholder="0" />
            </div>
            <div class="flex items-center gap-3 text-sm">
              <span class="text-gray-700"># Frames: <strong id="diseaseFrameCount">0</strong></span>
              <span class="text-gray-700">Duration: <strong id="diseaseDurationSec">0.00</strong> sec</span>
            </div>
            <div class="flex items-center gap-2">
              <label class="text-sm font-medium text-gray-700">Segmentation Frame:</label>
              <input type="number" id="diseaseSegmentationFrame" class="border rounded p-1 text-sm w-20" min="0" step="1" placeholder="0" />
            </div>
          </div>
        </div>

        <div id="detailsSections" class="space-y-4"></div>
        <div class="mt-4">
          <label class="block font-medium mb-1">Additional Comments</label>
          <textarea id="diseaseComments" rows="3" class="w-full p-2 border rounded" placeholder="Comments..."></textarea>
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div id="rightPane" class="w-1/4">
      <div class="bg-white p-4 rounded shadow">
        <div class="flex justify-between items-center mb-3">
          <h2 class="text-lg font-semibold">Report</h2>
          <div class="flex gap-2">
            <button id="saveJSON" class="bg-green-600 text-white px-3 py-1 rounded text-sm">Save</button>
            <button id="loadSavedJSON" class="bg-blue-600 text-white px-3 py-1 rounded text-sm">Load Saved JSON</button>
            <button id="clearReport" class="bg-red-600 text-white px-3 py-1 rounded text-sm">Clear</button>
          </div>
        </div>
        <div id="reportContent" class="space-y-4 min-h-[40vh]"></div>
      </div>
      <div class="bg-white mt-4 p-4 rounded shadow">
        <label class="block font-medium mb-1">Overall Remarks</label>
        <textarea id="overallRemarks" rows="4" class="w-full p-2 border rounded" placeholder="Overall remarks"></textarea>
      </div>
      <div class="mt-4">
        <button id="generateSentencesReport"
          class="w-full bg-indigo-600 text-white px-4 py-3 rounded text-sm font-semibold hover:bg-indigo-700">
          Generate Sentences Report
        </button>
      </div>
    </div>
  </div>
</div>

<!-- hidden file input for loading saved JSON -->
<input id="jsonFile" type="file" accept="application/json, .json" style="display:none" />

<script>
/* ---------- Debug Logging ---------- */
const DEBUG = true; // Set to false to disable console logging
function log(...args) {
  if (DEBUG) console.log('[EHR Debug]', ...args);
}
function logError(...args) {
  console.error('[EHR Error]', ...args);
}
function logWarn(...args) {
  console.warn('[EHR Warning]', ...args);
}

/* ---------- CSV parsing ---------- */
function parseCSV(text){
  log('Starting CSV parse, text length:', text.length);

  if (!text || typeof text !== 'string') {
    logError('Invalid CSV input: text is empty or not a string');
    return [];
  }

  const rows = [];
  let row = [];
  let cur = "";
  let inQuotes = false;

  for(let i=0;i<text.length;i++){
    const ch = text[i];
    if(ch === '"'){
      if(inQuotes && text[i+1] === '"'){ cur += '"'; i++; continue; }
      inQuotes = !inQuotes;
      continue;
    }
    if(!inQuotes && (ch === "\r" || ch === "\n")){
      if(ch === "\r" && text[i+1] === "\n") i++;
      row.push(cur);
      rows.push(row);
      row = [];
      cur = "";
      continue;
    }
    if(!inQuotes && ch === ","){
      row.push(cur);
      cur = "";
      continue;
    }
    cur += ch;
  }
  if(cur !== "" || row.length){
    row.push(cur);
    rows.push(row);
  }
  if(!rows.length) {
    logWarn('CSV parsing resulted in no rows');
    return [];
  }

  const headers = rows[0].map(h => (h || "").trim());
  log('CSV headers found:', headers);

  // Validate required headers
  const requiredHeaders = ['Diagnosis', 'Section'];
  const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
  if (missingHeaders.length > 0) {
    logError('CSV missing required headers:', missingHeaders);
  }

  const result = rows.slice(1)
    .filter(r => r.some(c => (c || "").trim()))
    .map(r => {
      const obj = {};
      headers.forEach((h, idx) => {
        obj[h || ("col"+idx)] = (r[idx] || "").trim();
      });
      return obj;
    });

  log('CSV parsing complete. Rows parsed:', result.length);
  return result;
}

function expandRangeToken(t){
  const m = t.match(/^Range\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/i);
  if(!m) return null;
  const start = parseInt(m[1],10);
  const end   = parseInt(m[2],10);
  const arr = [];
  for(let i=start;i<end;i++) arr.push(""+i);
  return arr;
}

function isX(v){ return v && (""+v).toLowerCase().includes("x"); }
function isMultiFlag(v){
  if(!v) return false;
  const s = (""+v).toLowerCase();
  return s.includes("x") || s.includes("yes") || s.includes("multi");
}

/* ---------- Build DISEASES model from CSV ---------- */
function buildFromCSV(rows){
  log('Building DISEASES model from', rows.length, 'rows');
  DISEASES = {};
  rows.forEach(r => {
    const d = (r["Diagnosis"] || "").trim();
    if(!d) return;

    if(!DISEASES[d]){
      DISEASES[d] = {
        sections: {},
        locations: {},
        default_subloc: (r["Default_Sub_Location"] || "").trim()
      };
    }

    getLocationsForProcedure().forEach(loc => {
      if(isX(r[loc])) DISEASES[d].locations[loc] = true;
    });

    const sec = (r["Section"] || "General").trim();
    const sub = (r["Subsection"] || "").trim();
    const secHint = (r["Section_Hint"] || "").trim();
    const subHint = (r["Subsection_Hint"] || "").trim();
    const multi = isMultiFlag(r["Multi_Attribute"]);
    const defaultAttr = (r["Default_Attr"] || "").trim();

    if(!DISEASES[d].sections[sec]){
      DISEASES[d].sections[sec] = {
        rows: [],
        subsections: {},
        multi: false,
        hint: secHint || "",
        default_attrs: []
      };
    } else if(secHint && !DISEASES[d].sections[sec].hint){
      DISEASES[d].sections[sec].hint = secHint;
    }

    const secDef = DISEASES[d].sections[sec];

    if(!sub){
      secDef.rows.push(r);
      if(multi) secDef.multi = true;
      // Store default attribute for section level
      if(defaultAttr && !secDef.default_attrs.includes(defaultAttr)){
        secDef.default_attrs.push(defaultAttr);
      }
    } else {
      if(!secDef.subsections[sub]){
        secDef.subsections[sub] = {
          rows: [],
          multi: false,
          hint: subHint || "",
          default_attrs: []
        };
      } else if(subHint && !secDef.subsections[sub].hint){
        secDef.subsections[sub].hint = subHint;
      }
      secDef.subsections[sub].rows.push(r);
      if(multi) secDef.subsections[sub].multi = true;
      // Store default attribute for subsection level
      if(defaultAttr && !secDef.subsections[sub].default_attrs.includes(defaultAttr)){
        secDef.subsections[sub].default_attrs.push(defaultAttr);
      }
    }
  });

  // Prune diseases with no applicable locations for current procedure type
  Object.keys(DISEASES).forEach(d => {
    if (Object.keys(DISEASES[d].locations).length === 0) {
      delete DISEASES[d];
    }
  });

  log('DISEASES model built with', Object.keys(DISEASES).length, 'diseases');
}

/* ---------- hint helper (multiline + images, strip filenames, size from name) ---------- */
function createHintElement(text){
  const wrapper = document.createElement("div");
  wrapper.className = "text-xs italic text-gray-500 mb-1";

  const imgRegex = /([A-Za-z0-9_.\-\/]+?\.(?:png|jpe?g|webp))/ig;
  const imgs = [];
  let m;

  while ((m = imgRegex.exec(text)) !== null) {
    imgs.push(m[1]);
  }

  // remove filenames from the hint text
  let cleanedText = text.replace(imgRegex, "");
  cleanedText = cleanedText
    .replace(/[ \t]+\n/g, "\n")
    .replace(/\n{3,}/g, "\n\n")
    .trim();

  if(cleanedText){
    const textDiv = document.createElement("div");
    textDiv.className = "whitespace-pre-line";
    textDiv.textContent = cleanedText;
    wrapper.appendChild(textDiv);
  }

  if (imgs.length) {
    const imgRow = document.createElement("div");
    imgRow.className = "mt-1 flex flex-wrap gap-2";
    imgs.forEach(fname => {
      const img = document.createElement("img");
      img.src = "pictures/" + fname;
      img.alt = fname;

      const sizeMatch = fname.match(/_(\d+)x(\d+)\.(?:png|jpe?g|webp)$/i);
      if(sizeMatch){
        img.width  = parseInt(sizeMatch[1],10);
        img.height = parseInt(sizeMatch[2],10);
      } else {
        img.style.maxHeight = "360px";
        img.style.maxWidth  = "100%";
      }

      img.className = "border rounded";
      imgRow.appendChild(img);
    });
    wrapper.appendChild(imgRow);
  }

  return wrapper;
}

/* ---------- helpers for multi-input attributes ---------- */
function parseAttributePattern(attrStr){
  log('Parsing attribute pattern:', attrStr);

  // First, split by whitespace
  const rawTokens = attrStr.trim().split(/\s+/);
  const result = [];

  rawTokens.forEach(tok => {
    // Check if this token contains multiple box types (e.g., "int_box:int_box" or "int_box/int_box")
    // We need to split these into separate tokens while preserving the separator
    const boxPattern = /(int_box|float_box|alphanum_box)/gi;
    const matches = tok.match(boxPattern);

    if(matches && matches.length > 1){
      // Token contains multiple input boxes - need to split it
      const splitRegex = /(int_box|float_box|alphanum_box)/gi;
      const splitParts = tok.split(splitRegex);

      splitParts.forEach((part, idx) => {
        if(!part) return; // Skip empty parts

        const lower = part.toLowerCase();
        if(lower === "int_box"){
          result.push({ type: "int_box" });
        } else if(lower === "float_box"){
          result.push({ type: "float_box" });
        } else if(lower === "alphanum_box"){
          result.push({ type: "alphanum_box" });
        } else if(part.trim()){
          // This is a separator like ":" or "/"
          result.push({ type: "text", value: part });
        }
      });
    } else {
      // Single token - process normally
      const lower = tok.toLowerCase();
      if(lower === "int_box"){
        result.push({ type: "int_box" });
      } else if(lower === "float_box"){
        result.push({ type: "float_box" });
      } else if(lower === "alphanum_box"){
        result.push({ type: "alphanum_box" });
      } else {
        result.push({ type: "text", value: tok });
      }
    }
  });

  log('Parsed pattern result:', result);
  return result;
}

function groupHasAnyValue(group){
  if(!group || !Array.isArray(group.pattern) || !Array.isArray(group.values)) return false;
  for(let i=0;i<group.pattern.length;i++){
    const t = group.pattern[i];
    if(t.type === "int_box" || t.type === "float_box" || t.type === "alphanum_box"){
      const v = group.values[i];
      if(v && v.toString().trim() !== ""){
        return true;
      }
    }
  }
  return false;
}

function renderGroupLabel(group){
  if(!group || !Array.isArray(group.pattern)) return "";
  const vals = Array.isArray(group.values) ? group.values : [];

  // Show group only if any box has non-empty value
  if(!groupHasAnyValue(group)) return "";

  const txt = group.pattern.map((t,idx)=>{
    if(t.type === "text") return t.value;
    if(t.type === "int_box" || t.type === "float_box" || t.type === "alphanum_box"){
      return vals[idx] || "";
    }
    return "";
  }).join(" ");

  return txt.replace(/\s+/g," ").trim();
}

/* ---------- constants ---------- */

// Location columns for each procedure type
const ENDO_LOCATIONS = ['Esophagus', 'GE Junction', 'Stomach', 'Duodenum'];
const COLONO_LOCATIONS = [
  'Terminal Ileum', 'IC Valve', 'Caecum', 'Ascending Colon',
  'Transverse Colon', 'Descending Colon', 'Sigmoid', 'Rectum', 'Anal Canal'
];

function getLocationsForProcedure(type) {
  return (type || procedureType) === 'colonoscopy' ? COLONO_LOCATIONS : ENDO_LOCATIONS;
}

// Endoscopy sub-locations
const SUBLOCATIONS = {
  'Esophagus':['Cricopharynx','Upper','Middle','Lower','Whole esophagus','Anastomosis'],
  'GE Junction':['Z-line','Hiatal hernia','Diaphragmatic pinch'],
  'Stomach': null, // Stomach uses matrix layout - see STOMACH_SUBLOC_MATRIX
  'Duodenum': null // Duodenum uses matrix layout - see DUODENUM_SUBLOC_MATRIX
};

// Colonoscopy sub-locations (only Rectum has sub-locations)
const COLONO_SUBLOCATIONS = {
  'Terminal Ileum': [],
  'IC Valve': [],
  'Caecum': [],
  'Ascending Colon': [],
  'Transverse Colon': [],
  'Descending Colon': [],
  'Sigmoid': [],
  'Rectum': ['Anterior wall', 'Posterior wall', 'Right Lateral wall', 'Left Lateral wall'],
  'Anal Canal': []
};

function getSublocationsForLocation(loc) {
  if (SUBLOCATIONS[loc] !== undefined) return SUBLOCATIONS[loc];
  if (COLONO_SUBLOCATIONS[loc] !== undefined) return COLONO_SUBLOCATIONS[loc];
  return [];
}

// Stomach sub-location matrix structure
const STOMACH_SUBLOC_MATRIX = [
  { region: 'Antrum', isHeading: false, options: ['Lesser Curvature', 'Greater Curvature', 'Posterior Wall', 'Anterior Wall', 'Entire'] },
  { region: 'Incisura', isHeading: false, options: ['Lesser Curvature', 'Posterior Wall', 'Anterior Wall', 'Entire'] },
  { region: 'Lower Body', isHeading: false, options: ['Lesser Curvature', 'Greater Curvature', 'Posterior Wall', 'Anterior Wall', 'Entire'] },
  { region: 'Middle Upper Body', isHeading: false, options: ['Lesser Curvature', 'Greater Curvature', 'Posterior Wall', 'Anterior Wall', 'Entire'] },
  { region: 'Fundus', isHeading: false, options: ['Lesser Curvature', 'Greater Curvature', 'Posterior Wall', 'Anterior Wall', 'Entire'] },
  { region: 'Other', isHeading: true, options: ['Whole Stomach', 'Whole Body', 'Cardia', 'Prepyloric region', 'Pylorus', 'Anastomosis'] }
];

// Duodenum sub-location matrix structure
const DUODENUM_SUBLOC_MATRIX = [
  { region: 'D1 Bulb', isHeading: false, options: ['Anterior wall', 'Posterior wall', 'Superior wall', 'Inferior wall', 'Entire'] },
  { region: 'D2', isHeading: false, options: ['Ampullary region', 'Medial wall', 'Lateral wall', 'Inferior wall', 'Superior wall', 'Entire'] },
  { region: 'Other', isHeading: true, options: ['D1-D2 junction', 'D3', 'D4', 'Anastomosis', 'Major papilla', 'Minor papilla'] }
];

// Video file extensions (case-insensitive)
const VIDEO_EXTENSIONS = ['.mp4', '.avi', '.mov', '.mkv', '.wmv', '.flv', '.webm'];
const FPS = 25; // Frames per second for duration calculation

/* ---------- mutable global state ---------- */
let DISEASES = {};
let report = {};
let active = null;
let selectedMainLoc = 'Esophagus';

let retroData = {
  uhidList: [],
  videosByUhid: {},
  jsonCountByUhid: {},
  uhidFolderHandles: {},
  rootFolderHandle: null
};

let piiEnabled = false;
let loadedCsvFilename = null;
let loadedCsvText = null;
let lastSavedReportState = null;
let previousUhidSelection = '';

/* ---------- settings state ---------- */
let darkMode = false;
let procedureType = 'endoscopy';     // 'endoscopy' | 'colonoscopy'
let studyType = 'retrospective';    // 'retrospective' | 'prospective'
let displayMode = 'landscape';       // 'landscape' | 'portrait'
let prospectivePatient = { uhid: '', patientName: '', gender: '', age: '', indication: '' };
let portraitSelectedDisease = null;   // disease name focused in portrait mode (before location chosen)

/* ---------- conditional logic ---------- */
// Evaluate a single condition with section context for proper subsection matching
function evaluateSingleCondition(cond, sectionContext){
  if(!cond || !cond.trim()) return true;
  const s = cond.trim();

  const locMatch = s.match(/^Location\(\s*Main\s*=\s*(.+?)\s*\)$/i);
  if(locMatch) return selectedMainLoc === locMatch[1];

  const secMatch = s.match(/^Section\(\s*([^=]+?)\s*=\s*(.+?)\s*\)$/i);
  if(secMatch){
    if(!active) return false;
    const m = report[active.loc] && report[active.loc].diseases[active.disease];
    if(!m) return false;
    const secName = secMatch[1].trim();
    const attrValue = secMatch[2].trim();
    const sec = m.sections[secName];
    if(!sec) return false;

    // Check section-level attrs first
    if(sec.attrs && sec.attrs[attrValue]){
      log('Section condition matched in section attrs:', secName, '=', attrValue);
      return true;
    }

    // Also check all subsection attrs within that specific section
    if(sec.subsections){
      for(const subName of Object.keys(sec.subsections)){
        const sub = sec.subsections[subName];
        if(sub.attrs && sub.attrs[attrValue]){
          log('Section condition matched in subsection attrs:', secName, '->', subName, '=', attrValue);
          return true;
        }
      }
    }

    return false;
  }

  const subMatch = s.match(/^Subsection\(\s*([^=]+?)\s*=\s*(.+?)\s*\)$/i);
  if(subMatch){
    if(!active) return false;
    const m = report[active.loc] && report[active.loc].diseases[active.disease];
    if(!m) return false;
    const subName = subMatch[1].trim();
    const val = subMatch[2].trim();

    // If we have a section context, search within that section first
    if(sectionContext && m.sections[sectionContext]){
      const sec = m.sections[sectionContext];
      if(sec.subsections && sec.subsections[subName] &&
         sec.subsections[subName].attrs &&
         sec.subsections[subName].attrs[val]){
        log('Subsection condition matched in context section:', sectionContext, '->', subName, '=', val);
        return true;
      }
    }

    // Fallback: search all sections (for backward compatibility)
    return Object.values(m.sections || {}).some(sec =>
      sec.subsections && sec.subsections[subName] &&
      sec.subsections[subName].attrs &&
      sec.subsections[subName].attrs[val]
    );
  }

  log('Condition not recognized:', s);
  return false;
}

// Evaluate conditional with optional section context
function evaluateConditional(cond, sectionContext){
  if(!cond || !cond.trim()) return true;
  const s = cond.trim();

  // Check for OR conditions (split by " OR " - case insensitive)
  if(/\sOR\s/i.test(s)){
    const orParts = s.split(/\sOR\s/i);
    log('Evaluating OR condition with', orParts.length, 'parts');
    return orParts.some(part => evaluateConditional(part.trim(), sectionContext));
  }

  // Check for AND conditions (split by " AND " - case insensitive)
  if(/\sAND\s/i.test(s)){
    const andParts = s.split(/\sAND\s/i);
    log('Evaluating AND condition with', andParts.length, 'parts');
    return andParts.every(part => evaluateConditional(part.trim(), sectionContext));
  }

  // Single condition - evaluate directly with section context
  return evaluateSingleCondition(s, sectionContext);
}

/* ---------- Left columns (diseases) ---------- */
function populateColumns(){
  if (displayMode === 'portrait') { populateColumnsPortrait(); return; }

  ["col-esophagus","col-gejunction","col-stomach","col-duodenum"].forEach(id => {
    document.getElementById(id).innerHTML = "";
  });

  Object.keys(DISEASES).forEach(name => {
    const def = DISEASES[name];
    Object.keys(def.locations).forEach(loc => {
      const colId =
        loc === "Esophagus" ? "col-esophagus" :
        loc === "GE Junction" ? "col-gejunction" :
        loc === "Stomach" ? "col-stomach" : "col-duodenum";

      const btn = document.createElement("button");
      btn.className = "left-disease";
      btn.textContent = name;
      btn.dataset.loc = loc;
      btn.dataset.disease = name;

      btn.onclick = () => {
        selectedMainLoc = loc;
        addOrOpenDisease(loc, name);
        refreshLeftHighlights();
      };

      document.getElementById(colId).appendChild(btn);
    });
  });

  refreshLeftHighlights();
}

function refreshLeftHighlights(){
  if (displayMode === 'portrait') { refreshPortraitHighlights(); return; }

  document.querySelectorAll(".left-disease").forEach(btn => {
    const loc = btn.dataset.loc;
    const dn  = btn.dataset.disease;
    const inReport = !!(report[loc] && report[loc].diseases && report[loc].diseases[dn]);
    const isActive = !!(active && active.loc === loc && active.disease === dn);
    btn.classList.toggle("selected", inReport || isActive);
  });
}

/* ---------- Portrait mode: single-column disease list ---------- */

function populateColumnsPortrait(){
  const leftPane = document.getElementById('leftPane');
  if (!leftPane) return;

  // Get or create the portrait disease list container
  let list = document.getElementById('portraitDiseaseList');
  if (!list) {
    list = document.createElement('div');
    list.id = 'portraitDiseaseList';
    list.className = 'bg-white p-3 rounded shadow space-y-1 overflow-y-auto';
    list.style.maxHeight = '85vh';
    leftPane.insertBefore(list, leftPane.firstChild);
  }
  list.innerHTML = '';

  // Deduplicate: show each disease once
  const seen = new Set();
  Object.keys(DISEASES).forEach(name => {
    if (seen.has(name)) return;
    seen.add(name);

    const def = DISEASES[name];
    const locs = Object.keys(def.locations);

    const btn = document.createElement('button');
    btn.className = 'left-disease text-sm';
    btn.textContent = name;
    btn.dataset.disease = name;
    btn.dataset.locs = JSON.stringify(locs);

    // Highlight if in report
    const inReport = locs.some(l =>
      report[l] && report[l].diseases && report[l].diseases[name]
    );
    const isActive = !!(active && locs.includes(active.loc) && active.disease === name);
    if (inReport || isActive) btn.classList.add('selected');

    // Focus ring if this is the portrait-focused disease (not yet in report)
    if (portraitSelectedDisease === name && !inReport) {
      btn.classList.add('portrait-focused');
    }

    btn.onclick = () => {
      portraitSelectedDisease = name;

      // If disease is already in report, open existing instance
      const existingLoc = locs.find(l =>
        report[l] && report[l].diseases && report[l].diseases[name]
      );
      if (existingLoc) {
        selectedMainLoc = existingLoc;
        openDetails(existingLoc, name);
        renderSubLocChips();
        refreshPortraitHighlights();
        if (typeof updatePortraitLocationPills === 'function') updatePortraitLocationPills();
        return;
      }

      // Single-location disease: auto-add immediately
      if (locs.length === 1) {
        selectedMainLoc = locs[0];
        addOrOpenDisease(locs[0], name);
        renderSubLocChips();
        refreshPortraitHighlights();
        if (typeof updatePortraitLocationPills === 'function') updatePortraitLocationPills();
        return;
      }

      // Multi-location disease: just focus it, update location pills, wait for pill click
      refreshPortraitHighlights();
      if (typeof updatePortraitLocationPills === 'function') updatePortraitLocationPills();
    };

    list.appendChild(btn);
  });
}

function refreshPortraitHighlights(){
  const buttons = document.querySelectorAll('#portraitDiseaseList .left-disease');
  buttons.forEach(btn => {
    const name = btn.dataset.disease;
    const locs = JSON.parse(btn.dataset.locs || '[]');

    const inReport = locs.some(l =>
      report[l] && report[l].diseases && report[l].diseases[name]
    );
    const isActive = !!(active && locs.includes(active.loc) && active.disease === name);
    btn.classList.toggle('selected', inReport || isActive);

    // Focus ring for the currently focused disease (not yet in report)
    btn.classList.toggle('portrait-focused',
      portraitSelectedDisease === name && !inReport && !isActive);
  });
}

/* ---------- Sub-location chips (multi-select) ---------- */
function renderSubLocChips(){
  const el = document.getElementById("subloc-chips");
  el.innerHTML = "";

  let current = [];
  if(active && report[active.loc] && report[active.loc].diseases[active.disease]){
    const d = report[active.loc].diseases[active.disease];
    if(Array.isArray(d.sublocations)) current = d.sublocations;
  }

  // Special matrix layout for Stomach
  if(selectedMainLoc === 'Stomach'){
    renderSublocMatrix(el, current, STOMACH_SUBLOC_MATRIX);
    return;
  }

  // Special matrix layout for Duodenum
  if(selectedMainLoc === 'Duodenum'){
    renderSublocMatrix(el, current, DUODENUM_SUBLOC_MATRIX);
    return;
  }

  // Standard pill layout for other locations
  const options = getSublocationsForLocation(selectedMainLoc) || [];

  options.forEach(s => {
    const chip = document.createElement("button");
    chip.className = "pill";
    chip.textContent = s;

    if(current.includes(s)) chip.classList.add("pill-selected");

    chip.onclick = () => {
      if(!active || !report[active.loc] || !report[active.loc].diseases[active.disease]) return;
      const disease = report[active.loc].diseases[active.disease];
      if(!Array.isArray(disease.sublocations)) disease.sublocations = [];

      const idx = disease.sublocations.indexOf(s);
      if(idx >= 0){
        disease.sublocations.splice(idx,1);
        chip.classList.remove("pill-selected");
      } else {
        disease.sublocations.push(s);
        chip.classList.add("pill-selected");
      }

      updateDetailsSubtitle();
      renderReport();
      refreshLeftHighlights();
    };

    el.appendChild(chip);
  });
}

/* ---------- Sub-location matrix (for Stomach and Duodenum) ---------- */
function renderSublocMatrix(container, currentSelections, matrixDef){
  // Create a table-like grid for the matrix
  const table = document.createElement("div");
  table.className = "w-full";

  matrixDef.forEach((row, rowIdx) => {
    const rowDiv = document.createElement("div");
    rowDiv.className = "flex items-center gap-2 mb-2 pb-2 border-b border-gray-200 last:border-b-0";

    // First column - region name (pill or heading)
    const regionCell = document.createElement("div");
    regionCell.className = "w-36 flex-shrink-0";

    if(row.isHeading){
      // Just a text heading for "Other" row
      const heading = document.createElement("span");
      heading.className = "font-medium text-gray-700 text-sm";
      heading.textContent = row.region;
      regionCell.appendChild(heading);
    } else {
      // Selectable pill for region
      const regionPill = document.createElement("button");
      regionPill.className = "pill w-full text-center";
      regionPill.textContent = row.region;
      regionPill.dataset.region = row.region;
      regionPill.dataset.rowIdx = rowIdx;

      if(currentSelections.includes(row.region)){
        regionPill.classList.add("pill-selected");
      }

      regionPill.onclick = () => {
        toggleMatrixRegion(row.region);
      };

      regionCell.appendChild(regionPill);
    }

    rowDiv.appendChild(regionCell);

    // Second column - options
    const optionsCell = document.createElement("div");
    optionsCell.className = "flex flex-wrap gap-2";

    row.options.forEach(opt => {
      // Create compound key for storage: "Region - Option" (except for Other row)
      const storageKey = row.isHeading ? opt : `${row.region} - ${opt}`;

      const optPill = document.createElement("button");
      optPill.className = "pill";
      optPill.textContent = opt;
      optPill.dataset.region = row.region;
      optPill.dataset.option = opt;
      optPill.dataset.storageKey = storageKey;
      optPill.dataset.isHeading = row.isHeading;

      if(currentSelections.includes(storageKey)){
        optPill.classList.add("pill-selected");
      }

      optPill.onclick = () => {
        toggleMatrixOption(row.region, opt, storageKey, row.isHeading);
      };

      optionsCell.appendChild(optPill);
    });

    rowDiv.appendChild(optionsCell);
    table.appendChild(rowDiv);
  });

  container.appendChild(table);
}

function toggleMatrixRegion(region){
  if(!active || !report[active.loc] || !report[active.loc].diseases[active.disease]) return;
  const disease = report[active.loc].diseases[active.disease];
  if(!Array.isArray(disease.sublocations)) disease.sublocations = [];

  const idx = disease.sublocations.indexOf(region);
  if(idx >= 0){
    // Deselecting region - also remove all its options
    disease.sublocations.splice(idx, 1);
    // Remove all "Region - Option" entries for this region
    disease.sublocations = disease.sublocations.filter(s => !s.startsWith(region + ' - '));
  } else {
    disease.sublocations.push(region);
  }

  updateDetailsSubtitle();
  renderReport();
  renderSubLocChips(); // Re-render to update UI
  refreshLeftHighlights();
}

function toggleMatrixOption(region, option, storageKey, isHeading){
  if(!active || !report[active.loc] || !report[active.loc].diseases[active.disease]) return;
  const disease = report[active.loc].diseases[active.disease];
  if(!Array.isArray(disease.sublocations)) disease.sublocations = [];

  const idx = disease.sublocations.indexOf(storageKey);
  if(idx >= 0){
    // Deselecting option
    disease.sublocations.splice(idx, 1);

    // If not a heading row, check if any other options for this region are still selected
    // If none, also deselect the region
    if(!isHeading){
      const hasOtherOptions = disease.sublocations.some(s => s.startsWith(region + ' - '));
      if(!hasOtherOptions){
        const regionIdx = disease.sublocations.indexOf(region);
        if(regionIdx >= 0){
          disease.sublocations.splice(regionIdx, 1);
        }
      }
    }
  } else {
    // Selecting option
    disease.sublocations.push(storageKey);

    // If not a heading row, auto-select the region if not already selected
    if(!isHeading && !disease.sublocations.includes(region)){
      disease.sublocations.push(region);
    }
  }

  updateDetailsSubtitle();
  renderReport();
  renderSubLocChips(); // Re-render to update UI
  refreshLeftHighlights();
}

function updateDetailsSubtitle(){
  const el = document.getElementById("detailsSubTitle");
  if(!active || !report[active.loc] || !report[active.loc].diseases[active.disease]){
    el.textContent = "";
    return;
  }
  const d = report[active.loc].diseases[active.disease];
  const subs = Array.isArray(d.sublocations) ? d.sublocations : [];
  el.textContent = "Sub-Locations: " + (subs.length ? subs.join(", ") : "\u2014");
}

/* ---------- disease add/open ---------- */
function addOrOpenDisease(loc, disease){
  log('Adding/opening disease:', disease, 'at location:', loc);
  if(!report[loc]) report[loc] = { diseases: {} };

  const isNewDisease = !report[loc].diseases[disease];

  if(isNewDisease){
    report[loc].diseases[disease] = {
      sections: {},
      comments: "",
      sublocations: []
    };
    const def = DISEASES[disease] && DISEASES[disease].default_subloc;
    if(def){
      report[loc].diseases[disease].sublocations = [def];
      log('Applied default sub-location:', def);
    }

    // Apply default attributes for all sections and subsections
    applyDefaultAttributes(disease, report[loc].diseases[disease]);
  }
  openDetails(loc, disease);
  renderReport();
  refreshLeftHighlights();
}

/* ---------- Apply default attributes to a newly added disease ---------- */
function applyDefaultAttributes(diseaseName, diseaseReport){
  const diseaseDef = DISEASES[diseaseName];
  if(!diseaseDef || !diseaseDef.sections) return;

  log('Applying default attributes for:', diseaseName);

  Object.keys(diseaseDef.sections).forEach(secName => {
    const secDef = diseaseDef.sections[secName];

    // Apply section-level defaults
    if(secDef.default_attrs && secDef.default_attrs.length > 0){
      if(!diseaseReport.sections[secName]){
        diseaseReport.sections[secName] = { attrs: {}, inputs: [], subsections: {} };
      }
      if(!diseaseReport.sections[secName].attrs){
        diseaseReport.sections[secName].attrs = {};
      }
      secDef.default_attrs.forEach(attr => {
        diseaseReport.sections[secName].attrs[attr] = true;
        log('Applied default section attr:', secName, '->', attr);
      });
    }

    // Apply subsection-level defaults
    Object.keys(secDef.subsections || {}).forEach(subName => {
      const subDef = secDef.subsections[subName];
      if(subDef.default_attrs && subDef.default_attrs.length > 0){
        if(!diseaseReport.sections[secName]){
          diseaseReport.sections[secName] = { attrs: {}, inputs: [], subsections: {} };
        }
        if(!diseaseReport.sections[secName].subsections[subName]){
          diseaseReport.sections[secName].subsections[subName] = { attrs: {}, inputs: [] };
        }
        if(!diseaseReport.sections[secName].subsections[subName].attrs){
          diseaseReport.sections[secName].subsections[subName].attrs = {};
        }
        subDef.default_attrs.forEach(attr => {
          diseaseReport.sections[secName].subsections[subName].attrs[attr] = true;
          log('Applied default subsection attr:', secName, '->', subName, '->', attr);
        });
      }
    });
  });
}

function openDetails(loc, disease){
  if(!report[loc] || !report[loc].diseases[disease]) return;
  active = { loc, disease };
  selectedMainLoc = loc;

  document.getElementById("detailsCard").classList.remove("hidden");
  document.getElementById("detailsTitle").textContent = disease;

  renderSubLocChips();
  updateDetailsSubtitle();
  renderDetailsSections(disease);

  // Load disease-specific frame data - proper null/undefined handling
  const diseaseData = report[loc].diseases[disease];

  // Initialize frame fields if they don't exist
  if(diseaseData.startFrame === undefined) diseaseData.startFrame = null;
  if(diseaseData.endFrame === undefined) diseaseData.endFrame = null;
  if(diseaseData.segmentationFrame === undefined) diseaseData.segmentationFrame = null;

  // Set input values - use empty string for null/undefined, otherwise use the value
  document.getElementById("diseaseStartFrame").value =
    (diseaseData.startFrame !== null && diseaseData.startFrame !== undefined) ? diseaseData.startFrame : "";
  document.getElementById("diseaseEndFrame").value =
    (diseaseData.endFrame !== null && diseaseData.endFrame !== undefined) ? diseaseData.endFrame : "";
  document.getElementById("diseaseSegmentationFrame").value =
    (diseaseData.segmentationFrame !== null && diseaseData.segmentationFrame !== undefined) ? diseaseData.segmentationFrame : "";

  updateDiseaseFrameCalculations();

  document.getElementById("diseaseComments").value =
    report[loc].diseases[disease].comments || "";
}

// Calculate and update disease-specific frame count and duration
function updateDiseaseFrameCalculations() {
  const startFrame = parseInt(document.getElementById('diseaseStartFrame').value, 10) || 0;
  const endFrame = parseInt(document.getElementById('diseaseEndFrame').value, 10) || 0;

  const frameCountEl = document.getElementById('diseaseFrameCount');
  const durationEl = document.getElementById('diseaseDurationSec');

  // Check if we have valid inputs (at least one non-zero)
  const hasInput = startFrame > 0 || endFrame > 0;

  if (!hasInput) {
    frameCountEl.textContent = '0';
    frameCountEl.classList.remove('text-red-600');
    durationEl.textContent = '0.00';
    durationEl.classList.remove('text-red-600');
    return;
  }

  // Calculate frame count (can be negative if invalid)
  const frameCount = endFrame - startFrame + 1;
  const duration = frameCount / FPS;

  frameCountEl.textContent = frameCount;
  durationEl.textContent = duration.toFixed(2);

  // Show negative frame counts in red
  if (frameCount <= 0) {
    frameCountEl.classList.add('text-red-600');
    durationEl.classList.add('text-red-600');
  } else {
    frameCountEl.classList.remove('text-red-600');
    durationEl.classList.remove('text-red-600');
  }
}

// Save disease frame data when inputs change
function saveDiseaseFrameData() {
  if (!active) return;
  const diseaseData = report[active.loc].diseases[active.disease];

  const startFrame = document.getElementById('diseaseStartFrame').value;
  const endFrame = document.getElementById('diseaseEndFrame').value;
  const segFrame = document.getElementById('diseaseSegmentationFrame').value;

  diseaseData.startFrame = startFrame ? parseInt(startFrame, 10) : null;
  diseaseData.endFrame = endFrame ? parseInt(endFrame, 10) : null;
  diseaseData.segmentationFrame = segFrame ? parseInt(segFrame, 10) : null;

  updateDiseaseFrameCalculations();
  renderReport();
}

// Add event listeners for disease frame inputs
document.getElementById('diseaseStartFrame').addEventListener('input', saveDiseaseFrameData);
document.getElementById('diseaseEndFrame').addEventListener('input', saveDiseaseFrameData);
document.getElementById('diseaseSegmentationFrame').addEventListener('input', saveDiseaseFrameData);

/* ---------- details pane ---------- */
function renderDetailsSections(diseaseName){
  const container = document.getElementById("detailsSections");
  container.innerHTML = "";
  const defs = (DISEASES[diseaseName] && DISEASES[diseaseName].sections) || {};

  Object.keys(defs).forEach(secName => {
    const secDef = defs[secName];

    const box = document.createElement("div");
    box.className = "p-3 border rounded";

    const title = document.createElement("div");
    title.className = "font-semibold mb-1";
    const secMeta = secDef.multi ? "Multi-select" : "Single selection only";
    title.innerHTML = `${secName} <span class="italic text-xs text-gray-500">(${secMeta})</span>`;
    box.appendChild(title);

    if(secDef.hint){
      box.appendChild(createHintElement(secDef.hint));
    }

    // Track if section has any visible content
    let sectionHasVisibleContent = false;

    // Render section-level rows (those without subsection)
    // Filter by location - only show rows that have "x" for the current location
    (secDef.rows || [])
      .filter(r => !(r["Subsection"] || "").trim())
      .forEach(r => {
        // Check if this row applies to the current location
        if(!isX(r[selectedMainLoc])) return;
        // Pass section context to conditional evaluation
        if(!evaluateConditional(r["Conditional_on"], secName)) return;
        box.appendChild(renderRow(r, secName, null));
        sectionHasVisibleContent = true;
      });

    // Render subsections
    Object.keys(secDef.subsections || {}).forEach(subName => {
      const subDef = secDef.subsections[subName];

      // First check if any rows in this subsection pass their conditionals AND location filter
      const visibleRows = (subDef.rows || []).filter(r => {
        // Check location applicability first
        if(!isX(r[selectedMainLoc])) return false;
        // Then check conditional with section context
        return evaluateConditional(r["Conditional_on"], secName);
      });

      // If no rows are visible, don't render this subsection at all
      if (visibleRows.length === 0) return;

      const subBox = document.createElement("div");
      subBox.className = "mt-3 p-2 border rounded bg-gray-50";

      const st = document.createElement("div");
      st.className = "font-semibold text-sm mb-1";
      const subMeta = subDef.multi ? "Multi-select" : "Single selection only";
      st.innerHTML = `${subName} <span class="italic text-xs text-gray-500">(${subMeta})</span>`;
      subBox.appendChild(st);

      if(subDef.hint){
        subBox.appendChild(createHintElement(subDef.hint));
      }

      visibleRows.forEach(r => {
        subBox.appendChild(renderRow(r, secName, subName));
      });

      box.appendChild(subBox);
      sectionHasVisibleContent = true;
    });

    // Only add the section box if it has any visible content (rows or subsections)
    if (sectionHasVisibleContent) {
      container.appendChild(box);
    }
  });

  document.getElementById("diseaseComments").oninput = e => {
    if(!active) return;
    report[active.loc].diseases[active.disease].comments = e.target.value;
    renderReport();
  };
}

/* ---------- row rendering (supports multi input boxes) ---------- */
function renderRow(row, secName, subName){
  const wrap = document.createElement("div");
  wrap.className = "mt-2";

  const attrs = Object.keys(row)
    .filter(k => /^Attribute/i.test(k))
    .map(k => row[k])
    .filter(v => v && v.trim());

  const multi = isMultiFlag(row["Multi_Attribute"]);

  attrs.forEach(attrStr => {
    if(/^Range\(/i.test(attrStr)){
      (expandRangeToken(attrStr) || []).forEach(x => {
        wrap.appendChild(makePill(x, secName, subName, multi));
      });
      return;
    }

    if(/int_box|float_box|alphanum_box/i.test(attrStr)){
      wrap.appendChild(renderInputAttribute(attrStr, secName, subName));
    } else {
      wrap.appendChild(makePill(attrStr, secName, subName, multi));
    }
  });

  return wrap;
}

/* ---------- multi-input attribute renderer (lazy group, skip empty) ---------- */
function renderInputAttribute(attrStr, secName, subName){
  const wrap = document.createElement("div");
  wrap.className = "flex items-center flex-wrap gap-2 mt-2";

  const pattern = parseAttributePattern(attrStr);

  if(!active) return wrap;
  const model = report[active.loc].diseases[active.disease];

  if(!model.sections[secName])
    model.sections[secName] = { attrs:{}, inputs:[], subsections:{} };

  let inputsRef;
  if(subName){
    if(!model.sections[secName].subsections[subName])
      model.sections[secName].subsections[subName] = { attrs:{}, inputs:[] };
    inputsRef = model.sections[secName].subsections[subName].inputs;
  } else {
    inputsRef = model.sections[secName].inputs;
  }
  if(!Array.isArray(inputsRef)){
    inputsRef = [];
    if(subName){
      model.sections[secName].subsections[subName].inputs = inputsRef;
    } else {
      model.sections[secName].inputs = inputsRef;
    }
  }

  // Try to find existing group for this attribute (same rawKey)
  let group = inputsRef.find(i => i.type === "group" && i.rawKey === attrStr) || null;

  // Align pattern & values if group exists
  if(group){
    group.pattern = pattern;
    if(!Array.isArray(group.values)) group.values = [];
    if(group.values.length < pattern.length){
      group.values = group.values.concat(
        new Array(pattern.length - group.values.length).fill("")
      );
    } else if(group.values.length > pattern.length){
      group.values = group.values.slice(0, pattern.length);
    }
  }

  pattern.forEach((tok, idx) => {
    if(tok.type === "text"){
      const span = document.createElement("span");
      span.className = "text-sm";
      span.textContent = tok.value;
      wrap.appendChild(span);
    } else {
      const input = document.createElement("input");

      // Set input type based on token type
      if(tok.type === "int_box"){
        input.type = "number";
        input.step = "1";
        input.min = "0";
        input.className = "border rounded p-1 w-20"; // Narrow width for integers
      } else if(tok.type === "float_box"){
        input.type = "number";
        input.step = "0.1";
        input.min = "0";
        input.className = "border rounded p-1 w-24"; // Medium width for floats
      } else if(tok.type === "alphanum_box"){
        input.type = "text";
        input.className = "border rounded p-1 w-48"; // Wider for alphanumeric
      }

      // Pre-fill from existing group if present
      if(group && Array.isArray(group.values)){
        input.value = group.values[idx] || "";
      }

      input.oninput = () => {
        const val = input.value.trim();

        // Ensure up-to-date model refs inside handler
        let currentModel = report[active.loc].diseases[active.disease];
        if(!currentModel.sections[secName])
          currentModel.sections[secName] = { attrs:{}, inputs:[], subsections:{} };

        let currentInputs;
        if(subName){
          if(!currentModel.sections[secName].subsections[subName])
            currentModel.sections[secName].subsections[subName] = { attrs:{}, inputs:[] };
          currentInputs = currentModel.sections[secName].subsections[subName].inputs;
        } else {
          currentInputs = currentModel.sections[secName].inputs;
        }
        if(!Array.isArray(currentInputs)){
          currentInputs = [];
          if(subName){
            currentModel.sections[secName].subsections[subName].inputs = currentInputs;
          } else {
            currentModel.sections[secName].inputs = currentInputs;
          }
        }

        // Lazily create group only when there is some non-empty value
        if(!group){
          group = {
            type: "group",
            rawKey: attrStr,
            pattern: pattern,
            values: new Array(pattern.length).fill("")
          };
          currentInputs.push(group);
        }

        group.values[idx] = val;

        // If no values at all, remove group
        if(!groupHasAnyValue(group)){
          const pos = currentInputs.indexOf(group);
          if(pos >= 0){
            currentInputs.splice(pos, 1);
          }
          group = null;
        }

        renderReport();
      };

      wrap.appendChild(input);
    }
  });

  return wrap;
}

/* ---------- attribute pill ---------- */
function makePill(attr, secName, subName, multi){
  const btn = document.createElement("button");
  btn.className = "attr-pill";
  btn.textContent = attr;

  const m = active && report[active.loc] && report[active.loc].diseases[active.disease];
  if(m){
    const ref = subName
      ? m.sections[secName]?.subsections?.[subName]?.attrs
      : m.sections[secName]?.attrs;
    if(ref && ref[attr]) btn.classList.add("selected");
  }

  btn.onclick = () => {
    if(!active) return;
    const model = report[active.loc].diseases[active.disease];
    if(!model.sections[secName])
      model.sections[secName] = { attrs:{}, inputs:[], subsections:{} };

    if(subName){
      if(!model.sections[secName].subsections[subName])
        model.sections[secName].subsections[subName] = { attrs:{}, inputs:[] };
      const t = model.sections[secName].subsections[subName].attrs;
      if(multi){
        // Multi-select: toggle the attribute
        if(t[attr]) delete t[attr]; else t[attr] = true;
      } else {
        // Single-select: if already selected, deselect; otherwise select this one only
        if(t[attr]){
          delete t[attr]; // Toggle off if already selected
        } else {
          Object.keys(t).forEach(k => delete t[k]); // Clear others
          t[attr] = true;
        }
      }
    } else {
      const t = model.sections[secName].attrs;
      if(multi){
        // Multi-select: toggle the attribute
        if(t[attr]) delete t[attr]; else t[attr] = true;
      } else {
        // Single-select: if already selected, deselect; otherwise select this one only
        if(t[attr]){
          delete t[attr]; // Toggle off if already selected
        } else {
          Object.keys(t).forEach(k => delete t[k]); // Clear others
          t[attr] = true;
        }
      }
    }

    renderDetailsSections(active.disease);
    renderReport();
    refreshLeftHighlights();
  };

  return btn;
}

/* ---------- right-hand report ---------- */
function renderReport(){
  const rc = document.getElementById("reportContent");
  rc.innerHTML = "";

  Object.keys(report).forEach(loc => {
    const blk = document.createElement("div");
    blk.className = "border rounded bg-gray-50 p-2";

    const h = document.createElement("div");
    h.className = "text-blue-700 font-semibold mb-2";
    h.textContent = loc;
    blk.appendChild(h);

    Object.keys(report[loc].diseases).forEach(dn => {
      const e = report[loc].diseases[dn];

      const card = document.createElement("div");
      card.className = "bg-white p-3 rounded border relative";

      const close = document.createElement("button");
      close.className = "absolute right-2 top-2 text-red-500";
      close.textContent = "x";
      close.onclick = () => {
        delete report[loc].diseases[dn];
        if(!Object.keys(report[loc].diseases).length) delete report[loc];
        if(active && active.loc === loc && active.disease === dn){
          active = null;
          document.getElementById("detailsCard").classList.add("hidden");
        }
        renderReport();
        populateColumns();
        renderSubLocChips();
      };
      card.appendChild(close);

      const title = document.createElement("a");
      title.href = "#";
      title.className = "font-semibold text-sm";
      title.textContent = dn;
      title.onclick = e2 => {
        e2.preventDefault();
        openDetails(loc, dn);
        populateColumns();
      };
      card.appendChild(title);

      const meta = document.createElement("div");
      meta.className = "text-xs text-gray-600 mt-1";
      const subs = Array.isArray(e.sublocations) ? e.sublocations : [];
      meta.innerHTML = "<strong>Sub-Locations:</strong> " + (subs.length ? subs.join(", ") : "\u2014");
      card.appendChild(meta);

      // Show disease frame info if available
      if (e.startFrame !== null && e.startFrame !== undefined &&
          e.endFrame !== null && e.endFrame !== undefined) {
        const frameMeta = document.createElement("div");
        frameMeta.className = "text-xs text-gray-600 mt-1";
        const frameCount = e.endFrame - e.startFrame + 1;
        const duration = (frameCount / FPS).toFixed(2);
        let frameText = `<strong>Frames:</strong> ${e.startFrame} - ${e.endFrame} (${frameCount} frames, ${duration} sec)`;
        if (e.segmentationFrame !== null && e.segmentationFrame !== undefined) {
          frameText += ` | <strong>Seg:</strong> ${e.segmentationFrame}`;
        }
        frameMeta.innerHTML = frameText;
        card.appendChild(frameMeta);
      }

      const ul = document.createElement("ul");
      ul.className = "list-disc pl-5 mt-2 text-xs text-gray-700";

      let any = false;
      Object.keys(e.sections || {}).forEach(sn => {
        const s = e.sections[sn];
        const hasAttrs = s.attrs && Object.keys(s.attrs).length > 0;

        // Check if inputs have actual filled values (not just empty groups)
        const hasFilledInputs = (s.inputs || []).some(i => {
          if(i.type === "group"){
            return groupHasAnyValue(i);
          } else {
            return (i.label || i.value || "").trim() !== "";
          }
        });

        // Check if subsections have actual content
        const hasFilledSubs = Object.keys(s.subsections || {}).some(subn => {
          const sub = s.subsections[subn];
          const subHasAttrs = sub.attrs && Object.keys(sub.attrs).length > 0;
          const subHasFilledInputs = (sub.inputs || []).some(i => {
            if(i.type === "group"){
              return groupHasAnyValue(i);
            } else {
              return (i.label || i.value || "").trim() !== "";
            }
          });
          return subHasAttrs || subHasFilledInputs;
        });

        if(!(hasAttrs || hasFilledInputs || hasFilledSubs)) return;

        const sli = document.createElement("li");
        sli.textContent = sn;

        const subul = document.createElement("ul");
        subul.className = "list-disc pl-6";

        // plain attribute pills
        Object.keys(s.attrs || {}).forEach(a => {
          const li = document.createElement("li");
          li.textContent = a;
          subul.appendChild(li);
        });

        // section inputs - only show if they have values
        (s.inputs || []).forEach(i => {
          let txt = "";
          if(i.type === "group"){
            txt = renderGroupLabel(i);
          } else {
            txt = (i.label || i.value || "").trim();
          }
          if(!txt) return;
          const li = document.createElement("li");
          li.textContent = txt;
          subul.appendChild(li);
        });

        // subsections - only show if they have actual content
        Object.keys(s.subsections || {}).forEach(subn => {
          const sub = s.subsections[subn];

          // Check if this subsection has any actual content
          const subHasAttrs = sub.attrs && Object.keys(sub.attrs).length > 0;
          const subHasFilledInputs = (sub.inputs || []).some(i => {
            if(i.type === "group"){
              return groupHasAnyValue(i);
            } else {
              return (i.label || i.value || "").trim() !== "";
            }
          });

          if(!subHasAttrs && !subHasFilledInputs) return; // Skip empty subsections

          const subli = document.createElement("li");
          subli.textContent = subn;

          const ssubul = document.createElement("ul");
          ssubul.className = "list-disc pl-6";

          Object.keys(sub.attrs || {}).forEach(a => {
            const li = document.createElement("li");
            li.textContent = a;
            ssubul.appendChild(li);
          });

          (sub.inputs || []).forEach(i => {
            let txt = "";
            if(i.type === "group"){
              txt = renderGroupLabel(i);
            } else {
              txt = (i.label || i.value || "").trim();
            }
            if(!txt) return;
            const li = document.createElement("li");
            li.textContent = txt;
            ssubul.appendChild(li);
          });

          if(ssubul.children.length) subli.appendChild(ssubul);
          subul.appendChild(subli);
        });

        if(subul.children.length){
          sli.appendChild(subul);
          ul.appendChild(sli);
          any = true;
        }
      });

      if(e.comments){
        const cli = document.createElement("li");
        cli.textContent = "Comments: " + e.comments;
        ul.appendChild(cli);
        any = true;
      }

      if(any) card.appendChild(ul);
      blk.appendChild(card);
    });

    rc.appendChild(blk);
  });

  refreshLeftHighlights();
  if (typeof voiceScheduleSync === "function") voiceScheduleSync();
}

/* ---------- Retrospective Video Analysis ---------- */

function isVideoFile(filename) {
  const lowerName = filename.toLowerCase();
  return VIDEO_EXTENSIONS.some(ext => lowerName.endsWith(ext));
}

function isJsonFile(filename) {
  return filename.toLowerCase().endsWith('.json');
}

// Check if report has any data
function isReportEmpty() {
  if (!report || Object.keys(report).length === 0) return true;

  // Check if any location has diseases
  for (const loc of Object.keys(report)) {
    const diseases = report[loc].diseases || {};
    if (Object.keys(diseases).length > 0) return false;
  }
  return true;
}

// PII toggle handler
document.getElementById('piiToggle').addEventListener('click', function() {
  piiEnabled = !piiEnabled;
  if (piiEnabled) {
    this.classList.remove('bg-white', 'text-orange-600');
    this.classList.add('bg-orange-500', 'text-white');
  } else {
    this.classList.remove('bg-orange-500', 'text-white');
    this.classList.add('bg-white', 'text-orange-600');
  }
  log('PII toggled:', piiEnabled);
});

// Update PII button visual state
function updatePiiButtonState() {
  const btn = document.getElementById('piiToggle');
  if (piiEnabled) {
    btn.classList.remove('bg-white', 'text-orange-600');
    btn.classList.add('bg-orange-500', 'text-white');
  } else {
    btn.classList.remove('bg-orange-500', 'text-white');
    btn.classList.add('bg-white', 'text-orange-600');
  }
}

// Calculate and update frame count and duration
function updateFrameCalculations() {
  const startFrame = parseInt(document.getElementById('startFrame').value, 10) || 0;
  const endFrame = parseInt(document.getElementById('endFrame').value, 10) || 0;

  const frameCountEl = document.getElementById('frameCount');
  const durationEl = document.getElementById('durationSec');

  // Check if we have valid inputs (at least one non-zero)
  const hasInput = startFrame > 0 || endFrame > 0;

  if (!hasInput) {
    frameCountEl.textContent = '0';
    frameCountEl.classList.remove('text-red-600');
    durationEl.textContent = '0.00';
    durationEl.classList.remove('text-red-600');
    return;
  }

  // Calculate frame count (can be negative if invalid)
  const frameCount = endFrame - startFrame + 1;
  const duration = frameCount / FPS;

  frameCountEl.textContent = frameCount;
  durationEl.textContent = duration.toFixed(2);

  // Show negative frame counts in red
  if (frameCount <= 0) {
    frameCountEl.classList.add('text-red-600');
    durationEl.classList.add('text-red-600');
  } else {
    frameCountEl.classList.remove('text-red-600');
    durationEl.classList.remove('text-red-600');
  }
}

// Clear frame inputs and calculations
function clearFrameInputs() {
  document.getElementById('startFrame').value = '';
  document.getElementById('endFrame').value = '';
  document.getElementById('segmentationFrame').value = '';
  updateFrameCalculations();
}

// Add event listeners for frame input changes
document.getElementById('startFrame').addEventListener('input', updateFrameCalculations);
document.getElementById('endFrame').addEventListener('input', updateFrameCalculations);

// Load folder from directory handle (reusable function)
async function loadFolderFromHandle(dirHandle) {
  retroData.rootFolderHandle = dirHandle;
  retroData.uhidList = [];
  retroData.videosByUhid = {};
  retroData.jsonCountByUhid = {};
  retroData.uhidFolderHandles = {};

  const uhidSelect = document.getElementById('uhidSelect');
  uhidSelect.innerHTML = '<option value="">-- Select UHID --</option>';

  // Iterate through UHID folders
  for await (const entry of dirHandle.values()) {
    if (entry.kind === 'directory') {
      const uhid = entry.name;
      retroData.uhidList.push(uhid);
      retroData.uhidFolderHandles[uhid] = entry;
      retroData.videosByUhid[uhid] = [];
      retroData.jsonCountByUhid[uhid] = 0;

      // Get video files and count JSON files in this UHID folder
      for await (const fileEntry of entry.values()) {
        if (fileEntry.kind === 'file') {
          if (isVideoFile(fileEntry.name)) {
            retroData.videosByUhid[uhid].push(fileEntry.name);
          } else if (isJsonFile(fileEntry.name)) {
            retroData.jsonCountByUhid[uhid]++;
          }
        }
      }

      // Add UHID to dropdown with JSON count in parenthesis and color coding
      const option = document.createElement('option');
      option.value = uhid;
      const jsonCount = retroData.jsonCountByUhid[uhid];
      option.textContent = `${uhid} (${jsonCount})`;

      // Color code based on JSON count: black=0, blue=1, red=>1
      if (jsonCount === 0) {
        option.style.color = 'black';
      } else if (jsonCount === 1) {
        option.style.color = 'blue';
      } else {
        option.style.color = 'red';
      }

      uhidSelect.appendChild(option);
    }
  }

  // Sort UHIDs alphabetically
  retroData.uhidList.sort();

  // Re-sort dropdown options
  const options = Array.from(uhidSelect.options).slice(1); // Skip first "Select" option
  options.sort((a, b) => a.value.localeCompare(b.value));
  options.forEach(opt => uhidSelect.appendChild(opt));

  document.getElementById('csvNote').textContent = `Loaded ${retroData.uhidList.length} UHID folders from "${dirHandle.name}"`;
  log('Loaded UHID folders:', retroData.uhidList.length);
}

// Update JSON count for a specific UHID in the dropdown
function updateUhidJsonCount(uhid) {
  if (!uhid || !retroData.jsonCountByUhid.hasOwnProperty(uhid)) return;

  retroData.jsonCountByUhid[uhid]++;

  const uhidSelect = document.getElementById('uhidSelect');
  const option = Array.from(uhidSelect.options).find(opt => opt.value === uhid);
  if (option) {
    const jsonCount = retroData.jsonCountByUhid[uhid];
    option.textContent = `${uhid} (${jsonCount})`;

    // Update color coding
    if (jsonCount === 0) {
      option.style.color = 'black';
    } else if (jsonCount === 1) {
      option.style.color = 'blue';
    } else {
      option.style.color = 'red';
    }
  }
}

// Try to load default retro_videos folder on page load
async function tryLoadDefaultRetroVideos() {
  // Note: Due to browser security, we cannot auto-load a folder without user interaction
  // But we can try to use a previously granted permission if available
  log('Checking for default retro_videos folder...');
  document.getElementById('csvNote').textContent = 'Click "Load Videos Folder" to select the retro_videos folder, or load a CSV file.';
}

// Load Videos Folder button handler
document.getElementById('loadVideoFolder').addEventListener('click', async function() {
  if (!('showDirectoryPicker' in window)) {
    alert('Your browser does not support the File System Access API. Please use a modern browser like Chrome or Edge.');
    return;
  }

  try {
    log('Opening folder picker for retro_videos...');
    const dirHandle = await window.showDirectoryPicker({
      mode: 'readwrite'
    });

    await loadFolderFromHandle(dirHandle);

  } catch (err) {
    if (err.name === 'AbortError') {
      log('Folder selection cancelled by user');
    } else {
      logError('Error loading videos folder:', err);
      alert('Error loading folder: ' + err.message);
    }
  }
});

// Reload folder when UHID dropdown is clicked (to refresh JSON counts)
document.getElementById('uhidSelect').addEventListener('click', async function() {
  if (retroData.rootFolderHandle) {
    log('Reloading folder on UHID dropdown click...');
    const currentUhid = this.value; // Remember current selection
    await loadFolderFromHandle(retroData.rootFolderHandle);

    // Restore selection if it still exists
    if (currentUhid && retroData.uhidList.includes(currentUhid)) {
      this.value = currentUhid;
    }
    // Update previousUhidSelection after reload to ensure it's correct
    previousUhidSelection = this.value;
  }
});

// Check if report has unsaved changes
function hasUnsavedChanges() {
  if (isReportEmpty()) return false;
  const currentState = JSON.stringify(report);
  return currentState !== lastSavedReportState;
}

// Store previous selection when dropdown gets focus (before click handler runs)
document.getElementById('uhidSelect').addEventListener('mousedown', function() {
  // Capture the value before any click processing happens
  previousUhidSelection = this.value;
  log('Captured previousUhidSelection on mousedown:', previousUhidSelection);
});

// Handle UHID selection change
document.getElementById('uhidSelect').addEventListener('change', async function(event) {
  const uhid = this.value;
  const videoSelect = document.getElementById('videoSelect');

  // Check for unsaved changes before switching
  if (hasUnsavedChanges()) {
    const proceed = confirm('You have unsaved data in the report. Changing UHID will clear it. Do you want to continue?');
    if (!proceed) {
      // Revert to previous selection
      log('Reverting to previousUhidSelection:', previousUhidSelection);
      this.value = previousUhidSelection;
      return;
    }
  }

  // Update previous selection to current
  previousUhidSelection = uhid;

  // Clear video dropdown
  videoSelect.innerHTML = '<option value="">-- Select Video --</option>';

  // Clear frame inputs when UHID changes
  clearFrameInputs();

  // Reset PII state
  piiEnabled = false;
  updatePiiButtonState();

  // Clear the brown text (csvNote) when UHID changes
  document.getElementById('csvNote').textContent = '';

  // Clear the report section and related data when UHID changes
  report = {};
  active = null;
  document.getElementById("detailsCard").classList.add("hidden");
  document.getElementById("overallRemarks").value = "";
  renderReport();
  populateColumns();
  renderSubLocChips();

  if (!uhid) {
    videoSelect.disabled = true;
    return;
  }

  // Populate videos for selected UHID
  const videos = retroData.videosByUhid[uhid] || [];
  videos.forEach(video => {
    const option = document.createElement('option');
    option.value = video;
    option.textContent = video;
    videoSelect.appendChild(option);
  });

  videoSelect.disabled = videos.length === 0;

  // Auto-select video if there's only one
  if (videos.length === 1) {
    videoSelect.value = videos[0];
    log('Auto-selected single video:', videos[0]);
  }

  log('UHID selected:', uhid, 'Videos available:', videos.length);

  // Load the latest modified JSON from this UHID folder
  await loadLatestJsonFromUhid(uhid);
});

// Load the latest modified JSON file from a UHID folder
async function loadLatestJsonFromUhid(uhid) {
  if (!retroData.uhidFolderHandles || !retroData.uhidFolderHandles[uhid]) {
    log('No folder handle for UHID:', uhid);
    return;
  }

  try {
    const folderHandle = retroData.uhidFolderHandles[uhid];
    let latestFile = null;
    let latestTime = 0;

    // Find the most recently modified JSON file
    for await (const entry of folderHandle.values()) {
      if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.json')) {
        try {
          const file = await entry.getFile();
          if (file.lastModified > latestTime) {
            latestTime = file.lastModified;
            latestFile = file;
          }
        } catch (err) {
          logWarn('Could not get file info for:', entry.name, err);
        }
      }
    }

    if (latestFile) {
      log('Loading latest JSON file:', latestFile.name);
      const text = await latestFile.text();
      loadJsonFromText(text, latestFile.name, false);
    } else {
      log('No JSON files found in UHID folder:', uhid);
    }
  } catch (err) {
    logError('Error loading latest JSON from UHID folder:', err);
  }
}

// Handle Video selection change - clear frame inputs
document.getElementById('videoSelect').addEventListener('change', function() {
  clearFrameInputs();
  log('Video selected:', this.value);
});

/* ---------- JSON load (unified) ---------- */
// restoreUhidVideo: when true (manual file load), also restores UHID/video dropdowns
// when false (auto-load from UHID folder), skips UHID/video restoration
function loadJsonFromText(text, filename, restoreUhidVideo) {
  try {
    const parsedAll = JSON.parse(text);
    if (typeof parsedAll !== "object" || parsedAll === null)
      throw new Error("Invalid JSON structure");

    // Handle prospective metadata
    if (parsedAll.__prospMeta) {
      const meta = parsedAll.__prospMeta;
      log('Found prospective metadata:', meta);

      // Switch to prospective mode if needed
      if (studyType !== 'prospective' && typeof applyStudyType === 'function') {
        applyStudyType('prospective');
      }

      // Populate prospective fields
      prospectivePatient = {
        uhid: meta.uhid || '',
        patientName: meta.patientName || '',
        gender: meta.gender || '',
        age: meta.age || '',
        indication: meta.indication || ''
      };

      const fieldMap = {
        uhid: 'prospUhid',
        patientName: 'prospPatientName',
        gender: 'prospGender',
        age: 'prospAge',
        indication: 'prospIndication'
      };
      Object.entries(fieldMap).forEach(([key, elId]) => {
        const el = document.getElementById(elId);
        if (el) el.value = prospectivePatient[key];
      });
    }

    // Handle retrospective metadata
    if (parsedAll.__retroMeta) {
      const retroMeta = parsedAll.__retroMeta;
      log('Found retrospective metadata:', retroMeta);

      // Restore UHID and video selection (only for manual file load)
      if (restoreUhidVideo && retroMeta.uhid) {
        const uhidSelect = document.getElementById('uhidSelect');
        // Check if UHID exists in dropdown, if not add it
        let uhidOption = Array.from(uhidSelect.options).find(opt => opt.value === retroMeta.uhid);
        if (!uhidOption) {
          uhidOption = document.createElement('option');
          uhidOption.value = retroMeta.uhid;
          uhidOption.textContent = retroMeta.uhid;
          uhidSelect.appendChild(uhidOption);
          // Also add to retroData
          if (!retroData.uhidList.includes(retroMeta.uhid)) {
            retroData.uhidList.push(retroMeta.uhid);
          }
          if (!retroData.videosByUhid[retroMeta.uhid]) {
            retroData.videosByUhid[retroMeta.uhid] = [];
          }
        }
        uhidSelect.value = retroMeta.uhid;
      }

      // Restore video selection
      if (retroMeta.video) {
        const videoSelect = document.getElementById('videoSelect');
        let videoOption = Array.from(videoSelect.options).find(opt => opt.value === retroMeta.video);
        if (!videoOption) {
          videoOption = document.createElement('option');
          videoOption.value = retroMeta.video;
          videoOption.textContent = retroMeta.video;
          videoSelect.appendChild(videoOption);
          // Also add to retroData when doing manual load
          if (restoreUhidVideo && retroMeta.uhid) {
            if (!retroData.videosByUhid[retroMeta.uhid]) {
              retroData.videosByUhid[retroMeta.uhid] = [];
            }
            if (!retroData.videosByUhid[retroMeta.uhid].includes(retroMeta.video)) {
              retroData.videosByUhid[retroMeta.uhid].push(retroMeta.video);
            }
          }
        }
        videoSelect.value = retroMeta.video;
        videoSelect.disabled = false;
      }

      // Restore frame range
      if (retroMeta.startFrame !== null && retroMeta.startFrame !== undefined) {
        document.getElementById('startFrame').value = retroMeta.startFrame;
      }
      if (retroMeta.endFrame !== null && retroMeta.endFrame !== undefined) {
        document.getElementById('endFrame').value = retroMeta.endFrame;
      }
      if (retroMeta.segmentationFrame !== null && retroMeta.segmentationFrame !== undefined) {
        document.getElementById('segmentationFrame').value = retroMeta.segmentationFrame;
      }

      // Restore PII state
      if (retroMeta.pii !== null && retroMeta.pii !== undefined) {
        piiEnabled = retroMeta.pii;
        updatePiiButtonState();
      }

      updateFrameCalculations();
    }

    // Handle lastActive metadata
    let lastActive = null;
    if (parsedAll.__meta && parsedAll.__meta.lastActive) {
      lastActive = parsedAll.__meta.lastActive;
      log('Found lastActive in JSON:', lastActive);
    }

    // Handle overall remarks
    if (parsedAll.overallRemarks) {
      document.getElementById('overallRemarks').value = parsedAll.overallRemarks;
    }

    // Get report data (handle both old and new format)
    if (parsedAll.report) {
      report = parsedAll.report;
    } else {
      const tempReport = {...parsedAll};
      delete tempReport.__retroMeta;
      delete tempReport.__prospMeta;
      delete tempReport.__meta;
      delete tempReport.overallRemarks;
      report = tempReport;
    }

    // Auto-detect procedure type from report locations or metadata
    const metaProcedure = (parsedAll.__retroMeta && parsedAll.__retroMeta.procedureType)
      || (parsedAll.__prospMeta && parsedAll.__prospMeta.procedureType);
    if (metaProcedure && metaProcedure !== procedureType && typeof applyProcedureType === 'function') {
      applyProcedureType(metaProcedure);
    } else if (!metaProcedure) {
      // Heuristic: detect from location keys
      const reportLocs = Object.keys(parsedAll.report || report);
      const isColono = reportLocs.some(l => COLONO_LOCATIONS.includes(l));
      const isEndo = reportLocs.some(l => ENDO_LOCATIONS.includes(l));
      if (isColono && !isEndo && procedureType !== 'colonoscopy' && typeof applyProcedureType === 'function') {
        applyProcedureType('colonoscopy');
      } else if (isEndo && !isColono && procedureType !== 'endoscopy' && typeof applyProcedureType === 'function') {
        applyProcedureType('endoscopy');
      }
    }

    // Normalize sublocations
    Object.keys(report).forEach(loc => {
      const ds = report[loc].diseases || {};
      Object.keys(ds).forEach(dn => {
        const d = ds[dn];
        if (Array.isArray(d.sublocations)) {
        } else if (typeof d.sublocation === "string" && d.sublocation) {
          d.sublocations = [d.sublocation];
          delete d.sublocation;
        } else {
          d.sublocations = d.sublocations || [];
        }
      });
    });

    if (lastActive &&
        report[lastActive.loc] &&
        report[lastActive.loc].diseases &&
        report[lastActive.loc].diseases[lastActive.disease]) {
      active = { loc: lastActive.loc, disease: lastActive.disease };
    } else {
      active = null;
      const locKeys = Object.keys(report);
      for (const loc of locKeys) {
        const ds = report[loc].diseases || {};
        const dk = Object.keys(ds);
        if (dk.length) {
          active = { loc, disease: dk[0] };
          break;
        }
      }
    }

    if (active) selectedMainLoc = active.loc;

    populateColumns();
    renderSubLocChips();
    renderReport();

    if (active) {
      openDetails(active.loc, active.disease);
    } else {
      document.getElementById("detailsCard").classList.add("hidden");
    }

    // Mark the loaded report as "saved" so changing UHID won't warn unnecessarily
    lastSavedReportState = JSON.stringify(report);

    document.getElementById("csvNote").textContent = `Loaded: ${filename}`;
    log('JSON loaded successfully:', filename);
  } catch (err) {
    logError('Error parsing JSON:', err);
    alert("Could not load JSON file: " + err.message);
  }
}

/* ---------- PDF generation ---------- */

// Generate timestamp for filename
function generateTimestamp() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  return `${year}${month}${day}_${hours}${minutes}`;
}

// Generate PDF from report data
function generatePDF(data, filename) {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();

  let yPos = 20;
  const leftMargin = 15;
  const pageWidth = doc.internal.pageSize.getWidth();
  const maxWidth = pageWidth - 30;
  const lineHeight = 6;

  // Helper function to add text with word wrap and page break handling
  function addText(text, fontSize = 10, isBold = false, indent = 0) {
    doc.setFontSize(fontSize);
    doc.setFont('helvetica', isBold ? 'bold' : 'normal');

    const lines = doc.splitTextToSize(text, maxWidth - indent);
    lines.forEach(line => {
      if (yPos > 280) {
        doc.addPage();
        yPos = 20;
      }
      doc.text(line, leftMargin + indent, yPos);
      yPos += lineHeight;
    });
  }

  // Helper to add a horizontal line
  function addLine() {
    if (yPos > 280) {
      doc.addPage();
      yPos = 20;
    }
    doc.setDrawColor(200, 200, 200);
    doc.line(leftMargin, yPos, pageWidth - leftMargin, yPos);
    yPos += 4;
  }

  // Title
  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(30, 64, 175); // Blue color
  const pdfTitle = procedureType === 'colonoscopy' ? 'AIG Colonoscopy Report' : 'AIG Endoscopy Report';
  doc.text(pdfTitle, pageWidth / 2, yPos, { align: 'center' });
  yPos += 12;
  doc.setTextColor(0, 0, 0); // Reset to black

  // Retrospective metadata
  if (data.__retroMeta) {
    const meta = data.__retroMeta;
    addLine();
    addText('Video Information', 12, true);
    yPos += 2;

    if (meta.uhid) addText(`UHID: ${meta.uhid}`, 10, false, 5);
    if (meta.video) addText(`Video: ${meta.video}`, 10, false, 5);
    if (meta.startFrame !== null && meta.endFrame !== null) {
      const frameCount = meta.endFrame - meta.startFrame + 1;
      const duration = (frameCount / FPS).toFixed(2);
      addText(`Frame Range: ${meta.startFrame} - ${meta.endFrame}`, 10, false, 5);
      addText(`# Frames: ${frameCount}  |  Duration: ${duration} sec (at ${FPS} fps)`, 10, false, 5);
    }
    if (meta.segmentationFrame !== null && meta.segmentationFrame !== undefined) {
      addText(`Segmentation Frame: ${meta.segmentationFrame}`, 10, false, 5);
    }
    if (meta.pii !== null && meta.pii !== undefined) {
      addText(`PII: ${meta.pii ? 'Yes' : 'No'}`, 10, false, 5);
    }
    if (meta.csvFile) {
      addText(`CSV File: ${meta.csvFile}`, 10, false, 5);
    }
    if (meta.savedAt) {
      const savedDate = new Date(meta.savedAt).toLocaleString();
      addText(`Saved: ${savedDate}`, 10, false, 5);
    }
    yPos += 4;
  }

  // Prospective metadata
  if (data.__prospMeta) {
    const meta = data.__prospMeta;
    addLine();
    addText('Patient Information', 12, true);
    yPos += 2;
    if (meta.uhid) addText(`UHID: ${meta.uhid}`, 10, false, 5);
    if (meta.patientName) addText(`Patient Name: ${meta.patientName}`, 10, false, 5);
    if (meta.gender) addText(`Gender: ${meta.gender}`, 10, false, 5);
    if (meta.age) addText(`Age: ${meta.age}`, 10, false, 5);
    if (meta.indication) addText(`Indication: ${meta.indication}`, 10, false, 5);
    if (meta.csvFile) addText(`CSV File: ${meta.csvFile}`, 10, false, 5);
    if (meta.savedAt) {
      const savedDate = new Date(meta.savedAt).toLocaleString();
      addText(`Saved: ${savedDate}`, 10, false, 5);
    }
    yPos += 4;
  }

  // Report content
  const reportData = data.report || {};

  Object.keys(reportData).forEach(location => {
    const locData = reportData[location];
    const diseases = locData.diseases || {};

    if (Object.keys(diseases).length === 0) return;

    addLine();
    addText(location, 14, true);
    yPos += 2;

    Object.keys(diseases).forEach(diseaseName => {
      const disease = diseases[diseaseName];

      // Disease name
      addText(`\u2022 ${diseaseName}`, 11, true, 3);

      // Sub-locations
      const sublocs = disease.sublocations || [];
      if (sublocs.length > 0) {
        addText(`Sub-Location: ${sublocs.join(', ')}`, 10, false, 8);
      }

      // Disease-level frame info
      if (disease.startFrame !== null && disease.startFrame !== undefined &&
          disease.endFrame !== null && disease.endFrame !== undefined) {
        const frameCount = disease.endFrame - disease.startFrame + 1;
        const duration = (frameCount / FPS).toFixed(2);
        addText(`Frames: ${disease.startFrame} - ${disease.endFrame} (${frameCount} frames, ${duration} sec)`, 10, false, 8);
        if (disease.segmentationFrame !== null && disease.segmentationFrame !== undefined) {
          addText(`Segmentation Frame: ${disease.segmentationFrame}`, 10, false, 8);
        }
      }

      // Sections
      const sections = disease.sections || {};
      Object.keys(sections).forEach(sectionName => {
        const section = sections[sectionName];

        // Check if section has content
        const hasAttrs = section.attrs && Object.keys(section.attrs).length > 0;
        const hasFilledInputs = (section.inputs || []).some(i => {
          if (i.type === 'group') return groupHasAnyValue(i);
          return (i.label || i.value || '').trim() !== '';
        });
        const hasFilledSubs = Object.keys(section.subsections || {}).some(subName => {
          const sub = section.subsections[subName];
          const subHasAttrs = sub.attrs && Object.keys(sub.attrs).length > 0;
          const subHasInputs = (sub.inputs || []).some(i => {
            if (i.type === 'group') return groupHasAnyValue(i);
            return (i.label || i.value || '').trim() !== '';
          });
          return subHasAttrs || subHasInputs;
        });

        if (!hasAttrs && !hasFilledInputs && !hasFilledSubs) return;

        addText(`${sectionName}:`, 10, true, 8);

        // Section attributes
        Object.keys(section.attrs || {}).forEach(attr => {
          addText(`- ${attr}`, 10, false, 12);
        });

        // Section inputs
        (section.inputs || []).forEach(input => {
          let txt = '';
          if (input.type === 'group') {
            txt = renderGroupLabel(input);
          } else {
            txt = (input.label || input.value || '').trim();
          }
          if (txt) addText(`- ${txt}`, 10, false, 12);
        });

        // Subsections
        Object.keys(section.subsections || {}).forEach(subName => {
          const sub = section.subsections[subName];
          const subHasAttrs = sub.attrs && Object.keys(sub.attrs).length > 0;
          const subHasInputs = (sub.inputs || []).some(i => {
            if (i.type === 'group') return groupHasAnyValue(i);
            return (i.label || i.value || '').trim() !== '';
          });

          if (!subHasAttrs && !subHasInputs) return;

          addText(`${subName}:`, 10, false, 12);

          Object.keys(sub.attrs || {}).forEach(attr => {
            addText(`- ${attr}`, 10, false, 16);
          });

          (sub.inputs || []).forEach(input => {
            let txt = '';
            if (input.type === 'group') {
              txt = renderGroupLabel(input);
            } else {
              txt = (input.label || input.value || '').trim();
            }
            if (txt) addText(`- ${txt}`, 10, false, 16);
          });
        });
      });

      // Comments
      if (disease.comments) {
        addText(`Comments: ${disease.comments}`, 10, false, 8);
      }

      yPos += 3;
    });
  });

  // Overall remarks
  if (data.overallRemarks) {
    addLine();
    addText('Overall Remarks', 12, true);
    yPos += 2;
    addText(data.overallRemarks, 10, false, 5);
  }

  // Save PDF
  return doc.output('blob');
}

/* ---------- clear and save ---------- */

document.getElementById("clearReport").onclick = () => {
  if(!confirm("Clear entire report?")) return;
  report = {};
  active = null;
  document.getElementById("detailsCard").classList.add("hidden");
  document.getElementById("overallRemarks").value = "";

  if (studyType === 'prospective') {
    // Clear prospective fields
    ['prospUhid', 'prospPatientName', 'prospGender', 'prospAge', 'prospIndication'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.value = '';
    });
    prospectivePatient = { uhid: '', patientName: '', gender: '', age: '', indication: '' };
  } else {
    // Clear retrospective fields
    document.getElementById("startFrame").value = "";
    document.getElementById("endFrame").value = "";
    document.getElementById("segmentationFrame").value = "";
    document.getElementById("uhidSelect").value = "";
    document.getElementById("videoSelect").innerHTML = '<option value="">-- Select Video --</option>';
    document.getElementById("videoSelect").disabled = true;
    previousUhidSelection = "";
    piiEnabled = false;
    updatePiiButtonState();
    updateFrameCalculations();
  }

  // Reset saved state since report is now empty
  lastSavedReportState = JSON.stringify(report);

  renderReport();
  populateColumns();
  renderSubLocChips();
  document.getElementById("csvNote").textContent = "Report cleared.";
};

// Save JSON and PDF with retrospective or prospective data
document.getElementById("saveJSON").onclick = async () => {
  let out;
  let uhid;

  if (studyType === 'prospective') {
    // Prospective: use text field inputs
    uhid = prospectivePatient.uhid || '';

    out = {
      __prospMeta: {
        uhid: uhid || null,
        patientName: prospectivePatient.patientName || null,
        gender: prospectivePatient.gender || null,
        age: prospectivePatient.age || null,
        indication: prospectivePatient.indication || null,
        procedureType: procedureType,
        csvFile: loadedCsvFilename || null,
        savedAt: new Date().toISOString()
      },
      __meta: active ? { lastActive: active } : null,
      report: JSON.parse(JSON.stringify(report || {})),
      overallRemarks: document.getElementById('overallRemarks').value || ""
    };

    log('Saving report with prospective metadata:', out.__prospMeta);

  } else {
    // Retrospective: existing logic
    uhid = document.getElementById('uhidSelect').value;
    const video = document.getElementById('videoSelect').value;
    const startFrame = document.getElementById('startFrame').value;
    const endFrame = document.getElementById('endFrame').value;
    const segmentationFrame = document.getElementById('segmentationFrame').value;

    // Check for missing required fields and warn user
    const missingFields = [];
    if (!video) missingFields.push('Video');
    if (!startFrame) missingFields.push('Start Frame');
    if (!endFrame) missingFields.push('End Frame');

    // Check for invalid frame range (end < start)
    const startFrameNum = parseInt(startFrame, 10) || 0;
    const endFrameNum = parseInt(endFrame, 10) || 0;
    const hasFrameInput = startFrameNum > 0 || endFrameNum > 0;
    const isInvalidFrameRange = hasFrameInput && (endFrameNum < startFrameNum);

    if (isInvalidFrameRange) {
      const proceed = confirm(`Warning: Invalid frame range detected!\nEnd Frame (${endFrameNum}) is less than Start Frame (${startFrameNum}).\n\nDo you still want to save?`);
      if (!proceed) {
        return;
      }
    } else if (missingFields.length > 0) {
      const proceed = confirm(`Warning: The following fields are not filled:\n- ${missingFields.join('\n- ')}\n\nDo you still want to save?`);
      if (!proceed) {
        return;
      }
    }

    out = {
      __retroMeta: {
        uhid: uhid || null,
        video: video || null,
        startFrame: startFrame ? parseInt(startFrame, 10) : null,
        endFrame: endFrame ? parseInt(endFrame, 10) : null,
        segmentationFrame: segmentationFrame ? parseInt(segmentationFrame, 10) : null,
        pii: piiEnabled,
        procedureType: procedureType,
        csvFile: loadedCsvFilename || null,
        savedAt: new Date().toISOString()
      },
      __meta: active ? { lastActive: active } : null,
      report: JSON.parse(JSON.stringify(report || {})),
      overallRemarks: document.getElementById('overallRemarks').value || ""
    };

    log('Saving report with retro metadata:', out.__retroMeta);
  }

  // Update last saved state
  lastSavedReportState = JSON.stringify(report);

  // Generate filename base
  const timestamp = generateTimestamp();
  const filenameBase = uhid ? `${uhid}_${timestamp}` : `report_${timestamp}`;
  const jsonFilename = `${filenameBase}.json`;
  const pdfFilename = `${filenameBase}.pdf`;

  // Generate PDF blob
  let pdfBlob;
  try {
    pdfBlob = generatePDF(out, pdfFilename);
    log('PDF generated successfully');
  } catch (err) {
    logError('Error generating PDF:', err);
    alert('Error generating PDF: ' + err.message);
  }

  // Try to save to UHID folder if File System Access API is available
  if (retroData.uhidFolderHandles && retroData.uhidFolderHandles[uhid]) {
    try {
      const folderHandle = retroData.uhidFolderHandles[uhid];

      // Save JSON
      const jsonFileHandle = await folderHandle.getFileHandle(jsonFilename, { create: true });
      const jsonWritable = await jsonFileHandle.createWritable();
      await jsonWritable.write(JSON.stringify(out, null, 2));
      await jsonWritable.close();
      log('JSON saved to UHID folder:', jsonFilename);

      // Save PDF
      if (pdfBlob) {
        const pdfFileHandle = await folderHandle.getFileHandle(pdfFilename, { create: true });
        const pdfWritable = await pdfFileHandle.createWritable();
        await pdfWritable.write(pdfBlob);
        await pdfWritable.close();
        log('PDF saved to UHID folder:', pdfFilename);
      }

      // Update JSON count in dropdown
      updateUhidJsonCount(uhid);

      document.getElementById('csvNote').textContent = `Saved: ${jsonFilename} and ${pdfFilename} to ${uhid} folder`;
      return;
    } catch (err) {
      logWarn('Could not save to UHID folder, falling back to download:', err);
    }
  }

  // Fallback: Download the files
  // Download JSON
  const jsonBlob = new Blob([JSON.stringify(out, null, 2)], { type: "application/json" });
  const jsonUrl = URL.createObjectURL(jsonBlob);
  const jsonLink = document.createElement("a");
  jsonLink.href = jsonUrl;
  jsonLink.download = jsonFilename;
  jsonLink.click();
  URL.revokeObjectURL(jsonUrl);

  // Update JSON count in dropdown (even for downloads, to keep track)
  if (uhid) {
    updateUhidJsonCount(uhid);
  }

  // Download PDF
  if (pdfBlob) {
    const pdfUrl = URL.createObjectURL(pdfBlob);
    const pdfLink = document.createElement("a");
    pdfLink.href = pdfUrl;
    pdfLink.download = pdfFilename;
    setTimeout(() => {
      pdfLink.click();
      URL.revokeObjectURL(pdfUrl);
    }, 100); // Small delay to ensure both downloads trigger
  }

  document.getElementById('csvNote').textContent = `Downloaded: ${jsonFilename} and ${pdfFilename}`;
  log('Files download initiated');
};

/* ---------- CSV auto-load ---------- */

async function autoLoadCsv() {
  const isHttp = window.location.protocol === 'http:' || window.location.protocol === 'https:';

  const urls = isHttp
    ? ['/api/csv']
    : ['./EHR_Menu - 20260224.csv', '../EHR_Menu - 20260224.csv'];

  for (const url of urls) {
    try {
      const resp = await fetch(url);
      if (!resp.ok) continue;

      const text = await resp.text();
      if (!text || text.length < 20) continue;

      loadedCsvText = text;

      // Try to extract filename from Content-Disposition header or URL
      const cd = resp.headers.get('content-disposition');
      const filenameMatch = cd && cd.match(/filename="?([^";\n]+)"?/);
      loadedCsvFilename = filenameMatch ? filenameMatch[1] : url.split('/').pop();

      const rows = parseCSV(text);
      if (rows.length === 0) {
        log('Auto-loaded CSV had no valid rows');
        continue;
      }

      buildFromCSV(rows);
      populateColumns();
      renderSubLocChips();
      renderReport();

      const noteEl = document.getElementById('csvNote');
      if (noteEl) noteEl.textContent = 'CSV auto-loaded (' + rows.length + ' rows) - ' + loadedCsvFilename;

      const statusEl = document.getElementById('csvAutoStatus');
      if (statusEl) statusEl.textContent = 'Auto-loaded: ' + loadedCsvFilename;

      log('CSV auto-loaded:', loadedCsvFilename, rows.length, 'rows');
      return true;
    } catch (err) {
      log('CSV auto-load attempt failed for', url, ':', err.message);
    }
  }

  log('CSV auto-load: no source succeeded, manual upload available in settings');
  return false;
}

/* ---------- CSV upload, sample, and JSON file load ---------- */

document.getElementById("csvFile").addEventListener("change", e => {
  const f = e.target.files[0];
  if(!f) {
    logWarn('No file selected for CSV upload');
    return;
  }
  log('Loading CSV file:', f.name, 'size:', f.size, 'bytes');

  // Track the CSV filename
  loadedCsvFilename = f.name;

  const r = new FileReader();
  r.onerror = () => {
    logError('Failed to read CSV file:', r.error);
    document.getElementById("csvNote").textContent = "Error reading file!";
    alert("Could not read the CSV file. Please try again.");
  };
  r.onload = () => {
    try {
      log('CSV file read complete, parsing...');
      loadedCsvText = r.result;
      const rows = parseCSV(r.result);
      if(rows.length === 0){
        logWarn('CSV parsing returned no valid rows');
        document.getElementById("csvNote").textContent = "Warning: No data found in CSV!";
        return;
      }
      buildFromCSV(rows);
      populateColumns();
      renderSubLocChips();
      renderReport();
      document.getElementById("csvNote").textContent = "CSV loaded (" + rows.length + " rows) - " + f.name;
      log('CSV loaded successfully');
    } catch(err) {
      logError('Error processing CSV:', err);
      document.getElementById("csvNote").textContent = "Error processing CSV!";
      alert("Could not process the CSV file: " + err.message);
    }
  };
  r.readAsText(f);
});

document.getElementById("loadSample").onclick = () => {
  log('Loading sample CSV data');
  const sample = `Diagnosis,Section,Subsection,Default_Sub_Location,Conditional_on,Multi_Attribute,Default_Attr,Section_Hint,Subsection_Hint,Esophagus,GE Junction,Stomach,Duodenum,Attribute1,Attribute2,Attribute3
Suspected Barrett's Esophagus,Biopsy taken,,Lower,,single,Yes,Biopsy taken for suspected Barrett's.\nThis can be multiline.,,x,,,,"Yes","No",
Suspected Barrett's Esophagus,Texture,,Lower,,multi,,Describe the texture.\nbarrett_texture_800x400.jpg,,x,,,,"Velvety","Granular","Irregular surface pattern"
Suspected Barrett's Esophagus,Prague Classification,,Lower,,single,,Enter Prague C/M length.,,x,,,,"Range(0,10)","Range(0,10)",
Caustic Injury,Substance Type,,Upper,,single,,Type of substance ingested.,,x,,,,"acid","alkali","oxidizer"
Caustic Injury,Time_since_ingestion,,Upper,,single,,Time elapsed since ingestion.,,x,,,,"int_box mm from alphanum_box",,
Tumor Sample,Size,,Upper,,single,,Enter size.,,x,x,x,x,"float_box cm",,
Simple Distance,Distance from incisors,,Upper,,single,,Distance only.,,x,,,,"int_box",,
`;
  loadedCsvText = sample;
  const rows = parseCSV(sample);
  buildFromCSV(rows);
  populateColumns();
  renderSubLocChips();
  renderReport();
  document.getElementById("csvNote").textContent = "Sample loaded.";
  log('Sample CSV loaded');
};

// Load saved JSON via file picker
const jsonFileInput = document.getElementById("jsonFile");
document.getElementById("loadSavedJSON").onclick = () => jsonFileInput.click();

jsonFileInput.addEventListener("change", ev => {
  const f = ev.target.files[0];
  if(!f) {
    logWarn('No file selected for JSON load');
    return;
  }
  log('Loading JSON file:', f.name);
  const reader = new FileReader();
  reader.onerror = () => {
    logError('Failed to read JSON file:', reader.error);
    alert("Could not read the JSON file. Please try again.");
  };
  reader.onload = () => {
    loadJsonFromText(reader.result, f.name, true);
  };
  reader.readAsText(f);
  ev.target.value = "";
});

/* ---------- init ---------- */
(function init(){
  populateColumns();
  renderSubLocChips();
  updateFrameCalculations(); // Initialize frame count display
  tryLoadDefaultRetroVideos(); // Try to load default retro_videos folder
})();

/* ---------- Voice dictation module ---------- */

/*
 * Handles:
 *  - WebSocket connection to backend (ws://host/ws/voice)
 *  - Audio capture via AudioWorklet (16kHz PCM Int16)
 *  - Receiving transcript + report updates from backend
 *  - applyVoiceUpdate() to update UI from LLM-produced report JSON
 *  - Voice toggle button, transcript bar, status indicator
 */

// ── State ──

let voiceWs = null;            // WebSocket instance
let voiceAudioCtx = null;      // AudioContext (16kHz)
let voiceMediaStream = null;   // getUserMedia stream
let voiceActive = false;       // Dictation running

// ── applyVoiceUpdate ──

/**
 * Apply a voice-dictated report update to the UI.
 *
 * This is a lightweight version of loadJsonFromText() that:
 *  - Does NOT touch __retroMeta (UHID, video, frames, PII)
 *  - Does NOT update lastSavedReportState (keeps "unsaved" status)
 *  - DOES validate disease names against loaded DISEASES
 *  - DOES normalize sublocations
 *  - DOES preserve the currently active disease if it still exists
 *  - DOES call populateColumns(), renderSubLocChips(), renderReport(), openDetails()
 *
 * @param {object} data - { report: {...}, overallRemarks: "..." }
 */
function applyVoiceUpdate(data) {
  if (!data || typeof data !== "object") return;

  const newReport = data.report || {};
  const newRemarks = data.overallRemarks;

  // Validate disease names against loaded DISEASES
  const validDiseases = new Set(Object.keys(DISEASES));

  Object.keys(newReport).forEach(loc => {
    const locEntry = newReport[loc];
    if (!locEntry || !locEntry.diseases) return;
    Object.keys(locEntry.diseases).forEach(dn => {
      if (validDiseases.size > 0 && !validDiseases.has(dn)) {
        log("applyVoiceUpdate: removing unknown disease:", dn);
        delete locEntry.diseases[dn];
      }
    });
    // Remove empty locations
    if (!Object.keys(locEntry.diseases).length) {
      delete newReport[loc];
    }
  });

  // Normalize sublocations (same logic as loadJsonFromText)
  Object.keys(newReport).forEach(loc => {
    const ds = newReport[loc].diseases || {};
    Object.keys(ds).forEach(dn => {
      const d = ds[dn];
      if (Array.isArray(d.sublocations)) {
        // already good
      } else if (typeof d.sublocation === "string" && d.sublocation) {
        d.sublocations = [d.sublocation];
        delete d.sublocation;
      } else {
        d.sublocations = d.sublocations || [];
      }
      // Auto-add region names for matrix sublocations (e.g., "Antrum" for "Antrum - Posterior Wall")
      const toAdd = [];
      d.sublocations.forEach(s => {
        const dash = s.indexOf(' - ');
        if (dash > 0) {
          const region = s.substring(0, dash);
          if (!d.sublocations.includes(region) && !toAdd.includes(region)) {
            toAdd.push(region);
          }
        }
      });
      if (toAdd.length) d.sublocations.push(...toAdd);
    });
  });

  // Collect old disease set before replacing report
  const oldDiseases = new Set();
  Object.keys(report || {}).forEach(loc => {
    Object.keys((report[loc] || {}).diseases || {}).forEach(dn => {
      oldDiseases.add(loc + "::" + dn);
    });
  });

  // Apply to global state
  report = newReport;

  // Update overallRemarks if provided
  if (newRemarks !== undefined && newRemarks !== null) {
    document.getElementById("overallRemarks").value = newRemarks;
  }

  // Find newly added diseases
  let newestDisease = null;
  Object.keys(report).forEach(loc => {
    Object.keys((report[loc] || {}).diseases || {}).forEach(dn => {
      if (!oldDiseases.has(loc + "::" + dn)) {
        newestDisease = { loc, disease: dn };
      }
    });
  });

  // Switch to newest disease if one was added, otherwise preserve active
  if (newestDisease) {
    active = newestDisease;
  } else if (active && report[active.loc] &&
      report[active.loc].diseases &&
      report[active.loc].diseases[active.disease]) {
    // active is still valid — keep it
  } else {
    // Find first available disease
    active = null;
    const locKeys = Object.keys(report);
    for (const loc of locKeys) {
      const ds = report[loc].diseases || {};
      const dk = Object.keys(ds);
      if (dk.length) {
        active = { loc, disease: dk[0] };
        break;
      }
    }
  }

  if (active) selectedMainLoc = active.loc;

  // Re-render UI
  populateColumns();
  renderSubLocChips();
  renderReport();

  if (active) {
    openDetails(active.loc, active.disease);
  } else {
    document.getElementById("detailsCard").classList.add("hidden");
  }

  log("applyVoiceUpdate: report applied");
}

// ── WebSocket ──

function _voiceWsUrl() {
  const loc = window.location;
  const proto = loc.protocol === "https:" ? "wss:" : "ws:";
  return proto + "//" + loc.host + "/ws/voice";
}

function _voiceConnect() {
  if (voiceWs) return;

  const url = _voiceWsUrl();
  log("Voice WS connecting:", url);

  voiceWs = new WebSocket(url);

  voiceWs.onopen = () => {
    log("Voice WS connected");
    _voiceSetStatus("Connecting...");

    // Send init message with CSV and current report state
    const initMsg = {
      type: "init",
      csv_text: loadedCsvText || "",
      report: report,
      overallRemarks: document.getElementById("overallRemarks").value || "",
      procedure_type: procedureType || "endoscopy",
    };
    voiceWs.send(JSON.stringify(initMsg));
  };

  voiceWs.onmessage = (evt) => {
    let data;
    try {
      data = JSON.parse(evt.data);
    } catch (e) {
      logError("Voice WS bad JSON:", e);
      return;
    }
    _voiceHandleMessage(data);
  };

  voiceWs.onerror = (e) => {
    logError("Voice WS error:", e);
  };

  voiceWs.onclose = () => {
    log("Voice WS closed");
    voiceWs = null;
    if (voiceActive) {
      _voiceStop();
      _voiceSetStatus("Disconnected");
    }
  };
}

function _voiceDisconnect() {
  if (voiceWs) {
    try {
      voiceWs.send(JSON.stringify({ type: "stop" }));
    } catch (e) { /* ignore */ }
    voiceWs.close();
    voiceWs = null;
  }
}

function _voiceHandleMessage(data) {
  switch (data.type) {
    case "status":
      if (data.asr) _voiceSetStatus("Listening...");
      if (data.llm === "processing") _voiceSetStatus("AI Processing...");
      if (data.llm === "idle") _voiceSetStatus("Listening...");
      if (data.paused === true) {
        _voiceSetStatus("Paused");
        _voiceSetTranscript("PAUSED - say \"Resume dictation\" to continue", "paused");
      }
      if (data.paused === false) {
        _voiceSetStatus("Listening...");
      }
      break;

    case "interim_transcript":
      _voiceSetTranscript(data.text, "interim");
      break;

    case "final_transcript":
      _voiceSetTranscript(data.text, "final");
      break;

    case "report_update":
      applyVoiceUpdate(data);
      break;

    case "capture_photo":
      log("Capture photo command received (stub)");
      _voiceShowToast("Photo capture (not yet implemented)");
      break;

    case "error":
      logWarn("Voice error:", data.message);
      _voiceShowToast("Error: " + data.message);
      break;

    case "info":
      log("Voice info:", data.message);
      break;
  }
}

// Send current report state to backend (after manual UI edits)
function _voiceSyncReportState() {
  if (!voiceWs || voiceWs.readyState !== WebSocket.OPEN) return;
  voiceWs.send(JSON.stringify({
    type: "report_state",
    report: report,
    overallRemarks: document.getElementById("overallRemarks").value || "",
  }));
}

// ── Audio Capture ──

const VOICE_WORKLET_CODE = `
class PCMProcessor extends AudioWorkletProcessor {
  process(inputs) {
    const input = inputs[0];
    if (!input || !input[0]) return true;
    const float32 = input[0];
    const int16 = new Int16Array(float32.length);
    for (let i = 0; i < float32.length; i++) {
      const s = Math.max(-1, Math.min(1, float32[i]));
      int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    this.port.postMessage(int16.buffer, [int16.buffer]);
    return true;
  }
}
registerProcessor("pcm-processor", PCMProcessor);
`;

async function _voiceStartAudio() {
  try {
    voiceMediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: 16000,
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true,
      },
    });

    voiceAudioCtx = new AudioContext({ sampleRate: 16000 });

    // Load worklet from inline Blob URL
    const blob = new Blob([VOICE_WORKLET_CODE], { type: "application/javascript" });
    const workletUrl = URL.createObjectURL(blob);
    await voiceAudioCtx.audioWorklet.addModule(workletUrl);
    URL.revokeObjectURL(workletUrl);

    const source = voiceAudioCtx.createMediaStreamSource(voiceMediaStream);
    const workletNode = new AudioWorkletNode(voiceAudioCtx, "pcm-processor");

    workletNode.port.onmessage = (evt) => {
      if (voiceWs && voiceWs.readyState === WebSocket.OPEN) {
        voiceWs.send(evt.data); // ArrayBuffer of Int16 PCM
      }
    };

    source.connect(workletNode);
    workletNode.connect(voiceAudioCtx.destination); // needed for worklet to run

    log("Voice audio capture started (16kHz)");
  } catch (err) {
    logError("Voice audio error:", err);
    _voiceShowToast("Microphone error: " + err.message);
    throw err;
  }
}

function _voiceStopAudio() {
  if (voiceAudioCtx) {
    voiceAudioCtx.close().catch(() => {});
    voiceAudioCtx = null;
  }
  if (voiceMediaStream) {
    voiceMediaStream.getTracks().forEach(t => t.stop());
    voiceMediaStream = null;
  }
}

// ── Start / Stop ──

async function _voiceStart() {
  if (voiceActive) return;

  const btn = document.getElementById("voiceToggle");
  btn.disabled = true;
  btn.textContent = "Starting...";

  try {
    _voiceConnect();
    await _voiceStartAudio();
    voiceActive = true;
    btn.textContent = "Stop Dictation";
    btn.classList.remove("bg-green-600", "hover:bg-green-700");
    btn.classList.add("bg-red-600", "hover:bg-red-700");
    _voiceSetStatus("Listening...");
    document.getElementById("voiceTranscriptBar").classList.remove("hidden");
  } catch (err) {
    _voiceDisconnect();
    _voiceStopAudio();
    btn.textContent = "Start Dictation";
    _voiceSetStatus("");
  } finally {
    btn.disabled = false;
  }
}

function _voiceStop() {
  voiceActive = false;
  _voiceStopAudio();
  _voiceDisconnect();

  const btn = document.getElementById("voiceToggle");
  btn.textContent = "Start Dictation";
  btn.classList.remove("bg-red-600", "hover:bg-red-700");
  btn.classList.add("bg-green-600", "hover:bg-green-700");
  _voiceSetStatus("");
  document.getElementById("voiceTranscriptBar").classList.add("hidden");
}

// ── UI Helpers ──

function _voiceSetStatus(text) {
  const el = document.getElementById("voiceStatus");
  if (el) el.textContent = text;
}

function _voiceSetTranscript(text, mode) {
  const el = document.getElementById("voiceTranscriptText");
  if (!el) return;
  el.textContent = text;
  el.className = "text-sm truncate ";
  if (mode === "interim") {
    el.className += "text-gray-400 italic";
  } else if (mode === "paused") {
    el.className += "text-orange-600 font-semibold";
  } else {
    el.className += "text-gray-800";
  }
}

function _voiceShowToast(msg) {
  const bar = document.getElementById("voiceTranscriptText");
  if (bar) {
    bar.textContent = msg;
    bar.className = "text-sm truncate text-orange-600";
    setTimeout(() => {
      if (bar.textContent === msg) bar.textContent = "";
    }, 4000);
  }
}

function _voiceCheckEnabled() {
  const btn = document.getElementById("voiceToggle");
  if (!btn) return;

  // Disable if: no CSV loaded, file:// protocol, no getUserMedia
  const isHttp = window.location.protocol === "http:" || window.location.protocol === "https:";
  const hasMic = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
  const hasCsv = Object.keys(DISEASES).length > 0;

  const enabled = isHttp && hasMic && hasCsv;
  btn.disabled = !enabled;

  if (!isHttp) {
    btn.title = "Voice requires HTTP (use python server.py)";
  } else if (!hasMic) {
    btn.title = "Microphone not available";
  } else if (!hasCsv) {
    btn.title = "Load CSV first";
  } else {
    btn.title = "";
  }
}

// ── Manual Edit Sync ──
// Debounced sync: called from renderReport() to send state to backend
let _voiceSyncTimer = null;
function voiceScheduleSync() {
  if (!voiceActive) return;
  clearTimeout(_voiceSyncTimer);
  _voiceSyncTimer = setTimeout(() => {
    _voiceSyncReportState();
  }, 500);
}

// ── Init ──

(function initVoice() {
  const btn = document.getElementById("voiceToggle");
  if (!btn) return;

  btn.addEventListener("click", () => {
    if (voiceActive) {
      _voiceStop();
    } else {
      _voiceStart();
    }
  });

  // Check enabled state initially and when CSV loads
  _voiceCheckEnabled();

  // Re-check enabled state when CSV loads (loadedCsvText stored in 17-csv-upload.js)
  const csvInput = document.getElementById("csvFile");
  if (csvInput) {
    csvInput.addEventListener("change", () => setTimeout(_voiceCheckEnabled, 100));
  }
  const sampleBtn = document.getElementById("loadSample");
  if (sampleBtn) {
    sampleBtn.addEventListener("click", () => setTimeout(_voiceCheckEnabled, 100));
  }
})();

/* ---------- Sentences Report (LLM → Rich Text → PDF) ---------- */

// ── Build report payload ──

function _sentencesBuildPayload() {
  if (studyType === 'prospective') {
    return {
      __prospMeta: {
        uhid: prospectivePatient.uhid || null,
        patientName: prospectivePatient.patientName || null,
        gender: prospectivePatient.gender || null,
        age: prospectivePatient.age || null,
        indication: prospectivePatient.indication || null,
        csvFile: loadedCsvFilename || null,
      },
      report: JSON.parse(JSON.stringify(report || {})),
      overallRemarks: document.getElementById('overallRemarks').value || "",
    };
  }

  const uhid = document.getElementById('uhidSelect').value;
  const video = document.getElementById('videoSelect').value;
  const startFrame = document.getElementById('startFrame').value;
  const endFrame = document.getElementById('endFrame').value;
  const segFrame = document.getElementById('segmentationFrame').value;

  return {
    __retroMeta: {
      uhid: uhid || null,
      video: video || null,
      startFrame: startFrame ? parseInt(startFrame, 10) : null,
      endFrame: endFrame ? parseInt(endFrame, 10) : null,
      segmentationFrame: segFrame ? parseInt(segFrame, 10) : null,
      pii: piiEnabled,
      csvFile: loadedCsvFilename || null,
    },
    report: JSON.parse(JSON.stringify(report || {})),
    overallRemarks: document.getElementById('overallRemarks').value || "",
  };
}

// ── API call ──

async function _sentencesCallApi(reportData) {
  const resp = await fetch('/api/generate-report', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ report_data: reportData }),
  });

  if (!resp.ok) {
    const err = await resp.json().catch(() => ({ error: 'Unknown error' }));
    throw new Error(err.error || 'HTTP ' + resp.status);
  }

  const data = await resp.json();
  return data.html;
}

// ── Modal ──

let _sentencesQuill = null;

function _sentencesCreateModal() {
  const existing = document.getElementById('sentencesModal');
  if (existing) existing.remove();

  const overlay = document.createElement('div');
  overlay.id = 'sentencesModal';
  overlay.className = 'fixed inset-0 z-50 flex items-center justify-center';
  overlay.style.backgroundColor = 'rgba(0,0,0,0.5)';

  const modal = document.createElement('div');
  modal.className = 'bg-white rounded-lg shadow-2xl flex flex-col';
  modal.style.cssText = 'width: 80vw; height: 85vh; max-width: 1200px;';

  // Header
  const header = document.createElement('div');
  header.className = 'flex justify-between items-center px-6 py-4 border-b shrink-0';
  header.innerHTML =
    '<h2 class="text-xl font-bold text-gray-800">' + (procedureType === 'colonoscopy' ? 'Colonoscopy' : 'Endoscopy') + ' Sentences Report</h2>' +
    '<button id="sentencesCloseBtn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>';
  modal.appendChild(header);

  // Loading state
  const loadingDiv = document.createElement('div');
  loadingDiv.id = 'sentencesLoading';
  loadingDiv.className = 'flex-1 flex items-center justify-center';
  loadingDiv.innerHTML =
    '<div class="text-center">' +
    '<div class="inline-block w-12 h-12 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin mb-4"></div>' +
    '<p class="text-gray-600 text-lg">Generating report with AI...</p>' +
    '<p class="text-gray-400 text-sm mt-2">This may take a few seconds</p>' +
    '</div>';
  modal.appendChild(loadingDiv);

  // Editor wrapper (hidden initially)
  const editorWrapper = document.createElement('div');
  editorWrapper.id = 'sentencesEditorWrapper';
  editorWrapper.className = 'flex-1 flex flex-col hidden overflow-hidden';

  const editorContainer = document.createElement('div');
  editorContainer.id = 'sentencesEditor';
  editorContainer.className = 'flex-1 overflow-y-auto';
  editorWrapper.appendChild(editorContainer);

  modal.appendChild(editorWrapper);

  // Footer
  const footer = document.createElement('div');
  footer.id = 'sentencesFooter';
  footer.className = 'px-6 py-4 border-t flex justify-end gap-3 hidden shrink-0';
  footer.innerHTML =
    '<button id="sentencesPdfBtn" ' +
    'class="bg-green-600 text-white px-6 py-2 rounded font-semibold hover:bg-green-700">' +
    'Submit and Create PDF Report</button>';
  modal.appendChild(footer);

  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  // Close handlers
  document.getElementById('sentencesCloseBtn').onclick = _sentencesCloseModal;
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay) _sentencesCloseModal();
  });

  overlay._escHandler = function(e) {
    if (e.key === 'Escape') _sentencesCloseModal();
  };
  document.addEventListener('keydown', overlay._escHandler);

  return overlay;
}

function _sentencesInitQuill(htmlContent) {
  var loading = document.getElementById('sentencesLoading');
  var editorWrapper = document.getElementById('sentencesEditorWrapper');
  var footer = document.getElementById('sentencesFooter');

  loading.classList.add('hidden');
  editorWrapper.classList.remove('hidden');
  footer.classList.remove('hidden');

  _sentencesQuill = new Quill('#sentencesEditor', {
    theme: 'snow',
    modules: {
      toolbar: [
        [{ header: [1, 2, 3, false] }],
        ['bold', 'italic', 'underline'],
        [{ list: 'ordered' }, { list: 'bullet' }],
        [{ align: [] }],
        ['clean'],
      ],
    },
  });

  // Strip code fences if Gemini wraps output
  var cleaned = htmlContent;
  cleaned = cleaned.replace(/^```html?\s*/i, '');
  cleaned = cleaned.replace(/\s*```\s*$/, '');

  _sentencesQuill.root.innerHTML = cleaned;

  document.getElementById('sentencesPdfBtn').onclick = _sentencesGeneratePdf;
}

function _sentencesCloseModal() {
  var modal = document.getElementById('sentencesModal');
  if (modal) {
    document.removeEventListener('keydown', modal._escHandler);
    modal.remove();
  }
  _sentencesQuill = null;
}

// ── PDF generation from rich text ──

async function _sentencesGeneratePdf() {
  if (!_sentencesQuill) return;

  var btn = document.getElementById('sentencesPdfBtn');
  btn.disabled = true;
  btn.textContent = 'Generating PDF...';

  try {
    // Create a temporary container with print styling
    var printDiv = document.createElement('div');
    printDiv.style.cssText =
      'padding: 20px; font-family: "Times New Roman", serif; font-size: 12pt; ' +
      'line-height: 1.6; color: #000; max-width: 700px;';

    // Title
    var title = document.createElement('h1');
    title.style.cssText = 'text-align: center; color: #1e40af; font-size: 18pt; margin-bottom: 16px;';
    title.textContent = procedureType === 'colonoscopy' ? 'AIG Colonoscopy Report' : 'AIG Endoscopy Report';
    printDiv.appendChild(title);

    // Quill content
    var content = document.createElement('div');
    content.innerHTML = _sentencesQuill.root.innerHTML;

    // Style headings and paragraphs for PDF
    content.querySelectorAll('h1').forEach(function(el) { el.style.cssText = 'font-size: 18pt; font-weight: bold; margin-top: 12px;'; });
    content.querySelectorAll('h2').forEach(function(el) { el.style.cssText = 'font-size: 15pt; font-weight: bold; margin-top: 10px; color: #1e40af;'; });
    content.querySelectorAll('h3').forEach(function(el) { el.style.cssText = 'font-size: 13pt; font-weight: bold; margin-top: 8px;'; });
    content.querySelectorAll('p').forEach(function(el) { el.style.cssText = 'margin-bottom: 6px;'; });

    printDiv.appendChild(content);

    // Append to body (modal overlay covers viewport so user won't see it)
    // Must NOT use position:fixed or z-index:-1 — html2canvas can't render those
    printDiv.style.width = '700px';
    document.body.appendChild(printDiv);

    var timestamp = generateTimestamp();
    var uhid = (studyType === 'prospective') ? prospectivePatient.uhid : document.getElementById('uhidSelect').value;
    var filenameBase = uhid ? uhid + '_sentences_' + timestamp : 'sentences_report_' + timestamp;

    var opt = {
      margin: [15, 15, 15, 15],
      filename: filenameBase + '.pdf',
      image: { type: 'jpeg', quality: 0.98 },
      html2canvas: { scale: 2, useCORS: true },
      jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
    };

    await html2pdf().set(opt).from(printDiv).save();

    document.body.removeChild(printDiv);

    btn.textContent = 'PDF Downloaded!';
    setTimeout(function() {
      btn.disabled = false;
      btn.textContent = 'Submit and Create PDF Report';
    }, 2000);

    log('Sentences report PDF generated:', filenameBase + '.pdf');
  } catch (err) {
    logError('Sentences PDF error:', err);
    alert('Error generating PDF: ' + err.message);
    btn.disabled = false;
    btn.textContent = 'Submit and Create PDF Report';
  }
}

// ── Main handler ──

async function _sentencesGenerate() {
  if (!report || Object.keys(report).length === 0) {
    alert('No report data to generate from. Add findings first.');
    return;
  }

  var isHttp = window.location.protocol === 'http:' || window.location.protocol === 'https:';
  if (!isHttp) {
    alert('Generate Sentences Report requires the server (python server.py). Not available in file:// mode.');
    return;
  }

  var btn = document.getElementById('generateSentencesReport');
  btn.disabled = true;

  _sentencesCreateModal();

  try {
    var payload = _sentencesBuildPayload();
    var html = await _sentencesCallApi(payload);
    _sentencesInitQuill(html);
  } catch (err) {
    logError('Sentences report error:', err);
    _sentencesCloseModal();
    alert('Error generating sentences report: ' + err.message);
  } finally {
    btn.disabled = false;
  }
}

// ── Init ──

(function initSentencesReport() {
  var btn = document.getElementById('generateSentencesReport');
  if (btn) {
    btn.addEventListener('click', _sentencesGenerate);
  }
})();

/* ---------- Settings: procedure type, dark mode, study type, display mode ---------- */

/* ── Procedure type ── */

function applyProcedureType(type) {
  if (procedureType === type) return;

  procedureType = type;

  // Update radio buttons
  document.querySelectorAll('input[name="procedureType"]').forEach(r => {
    r.checked = (r.value === type);
  });

  // Update page title
  const titleEl = document.getElementById('pageTitle');
  if (titleEl) {
    titleEl.textContent = type === 'colonoscopy' ? 'AIG Colonoscopy Report' : 'AIG Endoscopy Report';
  }

  // Colonoscopy forces portrait mode; disable landscape radio
  _updateLandscapeAvailability();

  if (type === 'colonoscopy' && displayMode !== 'portrait') {
    applyDisplayMode('portrait');
  }

  // Clear report on procedure type switch
  report = {};
  active = null;
  selectedMainLoc = getLocationsForProcedure()[0];
  document.getElementById('detailsCard').classList.add('hidden');
  document.getElementById('overallRemarks').value = '';
  lastSavedReportState = JSON.stringify(report);

  // Stop voice if active
  if (typeof voiceActive !== 'undefined' && voiceActive && typeof _voiceStop === 'function') {
    _voiceStop();
  }

  // Rebuild DISEASES from CSV with new location columns
  if (loadedCsvText) {
    const rows = parseCSV(loadedCsvText);
    buildFromCSV(rows);
  }

  // If in portrait mode, rebuild location pills for new procedure type
  if (displayMode === 'portrait') {
    _rebuildPortraitLocationPills();
  }

  // Re-render everything
  populateColumns();
  renderSubLocChips();
  renderReport();

  // Persist
  localStorage.setItem('ehr_procedureType', type);
}

function _updateLandscapeAvailability() {
  const landscapeRadio = document.querySelector('input[name="displayMode"][value="landscape"]');
  const landscapeLabel = document.getElementById('landscapeLabel');
  const isColono = procedureType === 'colonoscopy';

  if (landscapeRadio) landscapeRadio.disabled = isColono;
  if (landscapeLabel) {
    landscapeLabel.style.opacity = isColono ? '0.4' : '';
    landscapeLabel.style.cursor = isColono ? 'not-allowed' : '';
  }
}

function _rebuildPortraitLocationPills() {
  const locPills = document.getElementById('locationPills');
  if (!locPills) return;

  locPills.innerHTML = '';
  getLocationsForProcedure().forEach(loc => {
    const pill = document.createElement('button');
    pill.className = 'pill';
    pill.textContent = loc;
    pill.dataset.loc = loc;
    pill.onclick = () => onPortraitLocationPillClick(loc);
    locPills.appendChild(pill);
  });
}

/* ── Dark mode ── */

function toggleDarkMode() {
  darkMode = !darkMode;
  document.body.classList.toggle('dark', darkMode);

  const toggle = document.getElementById('darkModeToggle');
  if (toggle) {
    toggle.classList.toggle('active', darkMode);
    toggle.classList.toggle('bg-blue-600', darkMode);
    toggle.classList.toggle('bg-gray-300', !darkMode);
  }

  // Also style the settings panel itself
  const panel = document.getElementById('settingsPanel');
  if (panel) {
    panel.classList.toggle('bg-gray-800', darkMode);
    panel.classList.toggle('bg-white', !darkMode);
    panel.classList.toggle('border-gray-600', darkMode);
    panel.querySelectorAll('.text-gray-700').forEach(el => {
      // handled by body.dark CSS overrides
    });
  }

  localStorage.setItem('ehr_darkMode', darkMode ? '1' : '0');
}

/* ── Study type ── */

function applyStudyType(type) {
  studyType = type;

  const retroEl = document.getElementById('retroControls');
  const prospEl = document.getElementById('prospControls');
  if (retroEl) retroEl.classList.toggle('hidden', type === 'prospective');
  if (prospEl) prospEl.classList.toggle('hidden', type === 'retrospective');

  // Hide/show disease-level frame controls in details pane
  const diseaseFrameBar = document.getElementById('diseaseFrameBar');
  if (diseaseFrameBar) diseaseFrameBar.classList.toggle('hidden', type === 'prospective');

  // Update radio buttons to match
  document.querySelectorAll('input[name="studyType"]').forEach(r => {
    r.checked = (r.value === type);
  });

  localStorage.setItem('ehr_studyType', type);
}

/* ── Display mode ── */

function applyDisplayMode(mode) {
  const prev = displayMode;
  displayMode = mode;

  // Update radio buttons
  document.querySelectorAll('input[name="displayMode"]').forEach(r => {
    r.checked = (r.value === mode);
  });

  if (mode === 'portrait') {
    _switchToPortrait();
  } else if (prev === 'portrait') {
    _switchToLandscape();
  }
}

function _switchToPortrait() {
  const mainLayout = document.getElementById('mainLayout');
  const leftPane = document.getElementById('leftPane');
  const rightPane = document.getElementById('rightPane');
  const diseaseGridCard = document.getElementById('diseaseGridCard');
  const diseaseColumnsGrid = document.getElementById('diseaseColumnsGrid');
  const sublocSection = document.getElementById('sublocSection');
  const detailsCard = document.getElementById('detailsCard');

  // Hide the entire disease grid card (columns + sublocation are moved out)
  if (diseaseGridCard) diseaseGridCard.classList.add('hidden');

  // Create center pane
  let centerPane = document.getElementById('centerPane');
  if (!centerPane) {
    centerPane = document.createElement('div');
    centerPane.id = 'centerPane';
    centerPane.className = 'space-y-4 min-w-0';
    mainLayout.insertBefore(centerPane, rightPane);
  }

  // Create location pills (dynamic based on procedure type)
  let locPills = document.getElementById('locationPills');
  if (!locPills) {
    locPills = document.createElement('div');
    locPills.id = 'locationPills';
    locPills.className = 'bg-white p-4 rounded shadow flex gap-3 flex-wrap';

    getLocationsForProcedure().forEach(loc => {
      const pill = document.createElement('button');
      pill.className = 'pill';
      pill.textContent = loc;
      pill.dataset.loc = loc;
      pill.onclick = () => onPortraitLocationPillClick(loc);
      locPills.appendChild(pill);
    });

    centerPane.appendChild(locPills);
  }

  // Move sublocation section to center pane
  if (sublocSection) centerPane.appendChild(sublocSection);

  // Move details card to center pane
  if (detailsCard) centerPane.appendChild(detailsCard);

  // Set grid layout on main
  mainLayout.style.display = 'grid';
  mainLayout.style.gridTemplateColumns = '20% 1fr 15%';
  mainLayout.style.gap = '1rem';

  // Left pane: narrow disease list
  leftPane.style.width = '100%';
  leftPane.classList.remove('w-3/4');

  // Right pane: sticky report
  rightPane.style.width = '100%';
  rightPane.classList.remove('w-1/4');
  rightPane.style.position = 'sticky';
  rightPane.style.top = '1rem';
  rightPane.style.maxHeight = 'calc(100vh - 2rem)';
  rightPane.style.overflowY = 'auto';
  rightPane.style.alignSelf = 'start';

  // Render portrait disease list
  populateColumns();
}

function _switchToLandscape() {
  const mainLayout = document.getElementById('mainLayout');
  const leftPane = document.getElementById('leftPane');
  const rightPane = document.getElementById('rightPane');
  const diseaseGridCard = document.getElementById('diseaseGridCard');
  const diseaseColumnsGrid = document.getElementById('diseaseColumnsGrid');
  const sublocSection = document.getElementById('sublocSection');
  const detailsCard = document.getElementById('detailsCard');

  // Show the disease grid card again
  if (diseaseGridCard) diseaseGridCard.classList.remove('hidden');

  // Move sublocation back into diseaseGridCard
  if (sublocSection && diseaseGridCard) diseaseGridCard.appendChild(sublocSection);

  // Move details card back to left pane
  if (detailsCard && leftPane) leftPane.appendChild(detailsCard);

  // Remove center pane and location pills
  const centerPane = document.getElementById('centerPane');
  if (centerPane) centerPane.remove();

  // Remove portrait disease list
  const portraitList = document.getElementById('portraitDiseaseList');
  if (portraitList) portraitList.remove();

  // Reset layout styles
  mainLayout.style.display = '';
  mainLayout.style.gridTemplateColumns = '';
  mainLayout.style.gap = '';

  leftPane.style.width = '';
  leftPane.classList.add('w-3/4');

  rightPane.style.width = '';
  rightPane.classList.add('w-1/4');
  rightPane.style.position = '';
  rightPane.style.top = '';
  rightPane.style.maxHeight = '';
  rightPane.style.overflowY = '';
  rightPane.style.alignSelf = '';

  // Reset portrait state
  portraitSelectedDisease = null;

  // Re-render normal columns
  populateColumns();
  renderSubLocChips();
}

/* ── Portrait location pill click ── */

function onPortraitLocationPillClick(loc) {
  if (portraitSelectedDisease) {
    const def = DISEASES[portraitSelectedDisease];
    if (!def) return;
    const locs = Object.keys(def.locations);

    // Only act if disease applies to this location
    if (!locs.includes(loc)) return;

    // Add or open the disease at this location
    selectedMainLoc = loc;
    addOrOpenDisease(loc, portraitSelectedDisease);
    renderSubLocChips();
    refreshPortraitHighlights();
    updatePortraitLocationPills();
  } else {
    // No disease focused — just switch sublocation view
    selectedMainLoc = loc;
    renderSubLocChips();
    updatePortraitLocationPills();
  }
}

/* ── Update portrait location pill states ── */

function updatePortraitLocationPills() {
  const pills = document.querySelectorAll('#locationPills .pill');
  if (!pills.length) return;

  // Get applicable locations for the focused or active disease
  let applicableLocs = [];
  const dn = portraitSelectedDisease || (active && active.disease);
  if (dn && DISEASES[dn]) {
    applicableLocs = Object.keys(DISEASES[dn].locations);
  }

  pills.forEach(btn => {
    const loc = btn.dataset.loc;
    const hasDisease = applicableLocs.length === 0 || applicableLocs.includes(loc);
    const isCurrent = !!(active && active.loc === loc);

    // Grey out inapplicable locations
    btn.classList.toggle('portrait-greyed', !hasDisease);
    btn.disabled = !hasDisease;

    // Highlight the current active location
    btn.classList.toggle('pill-selected', isCurrent && hasDisease);
  });
}

/* ── Prospective patient input listeners ── */

function _wireProspectiveInputs() {
  const fields = {
    'prospUhid': 'uhid',
    'prospPatientName': 'patientName',
    'prospGender': 'gender',
    'prospAge': 'age',
    'prospIndication': 'indication'
  };

  Object.entries(fields).forEach(([elId, key]) => {
    const el = document.getElementById(elId);
    if (el) {
      el.addEventListener('input', () => {
        prospectivePatient[key] = el.value;
      });
    }
  });
}

/* ── Settings panel init ── */

(function initSettings() {
  const gearBtn = document.getElementById('settingsGearBtn');
  const panel = document.getElementById('settingsPanel');

  // Toggle settings panel
  if (gearBtn && panel) {
    gearBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      panel.classList.toggle('hidden');
    });

    // Close on click outside
    document.addEventListener('click', (e) => {
      if (!panel.contains(e.target) && e.target !== gearBtn) {
        panel.classList.add('hidden');
      }
    });
  }

  // Procedure type radios
  document.querySelectorAll('input[name="procedureType"]').forEach(radio => {
    radio.addEventListener('change', () => {
      if (radio.checked) applyProcedureType(radio.value);
    });
  });

  // Dark mode toggle
  const darkToggle = document.getElementById('darkModeToggle');
  if (darkToggle) {
    darkToggle.addEventListener('click', toggleDarkMode);
  }

  // Study type radios
  document.querySelectorAll('input[name="studyType"]').forEach(radio => {
    radio.addEventListener('change', () => {
      if (radio.checked) applyStudyType(radio.value);
    });
  });

  // Display mode radios
  document.querySelectorAll('input[name="displayMode"]').forEach(radio => {
    radio.addEventListener('change', () => {
      if (radio.checked) applyDisplayMode(radio.value);
    });
  });

  // Prospective input listeners
  _wireProspectiveInputs();

  // Restore saved settings from localStorage
  if (localStorage.getItem('ehr_darkMode') === '1') {
    toggleDarkMode();
  }

  const savedStudy = localStorage.getItem('ehr_studyType');
  if (savedStudy && savedStudy !== 'retrospective') {
    applyStudyType(savedStudy);
  }

  // Restore procedure type (lightweight: set state + UI, don't clear report or rebuild)
  const savedProcedure = localStorage.getItem('ehr_procedureType');
  if (savedProcedure && savedProcedure !== 'endoscopy') {
    procedureType = savedProcedure;
    document.querySelectorAll('input[name="procedureType"]').forEach(r => {
      r.checked = (r.value === savedProcedure);
    });
    const titleEl = document.getElementById('pageTitle');
    if (titleEl) {
      titleEl.textContent = savedProcedure === 'colonoscopy' ? 'AIG Colonoscopy Report' : 'AIG Endoscopy Report';
    }
    selectedMainLoc = getLocationsForProcedure()[0];
    _updateLandscapeAvailability();
    if (savedProcedure === 'colonoscopy') {
      applyDisplayMode('portrait');
    }
  }

  // Display mode is NOT persisted — always starts in landscape (unless colonoscopy forces portrait)

  // Auto-load CSV (runs after all settings are restored so procedureType is correct)
  if (typeof autoLoadCsv === 'function') {
    autoLoadCsv();
  }
})();

</script>
</body>
</html>
